text
React:  Programmatic React features: Hooks - Use different React features from your components. Components - Documents built-in components that you can use in your JSX. APIs - APIs that are useful for defining components. Directives - Provide instructions to bundlers compatible with React Server Components.
React DOM:  React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following: Hooks - Hooks for web applications which run in the browser DOM environment. Components - React supports all of the browser built-in HTML and SVG components. APIs - The react-dom package contains methods supported only in web applications. Client APIs - The react-dom/client APIs let you render React components on the client (in the browser). Server APIs - The react-dom/server APIs let you render React components to HTML on the server.
"Rules of React:  React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications: Components and Hooks must be pure – Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly. React calls Components and Hooks – React is responsible for rendering components and hooks when necessary to optimize the user experience. Rules of Hooks – Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called."
"Legacy APIs:  Legacy APIs - Exported from the react package, but not recommended for use in newly written code."
React:  Programmatic React features: Hooks - Use different React features from your components. Components - Documents built-in components that you can use in your JSX. APIs - APIs that are useful for defining components. Directives - Provide instructions to bundlers compatible with React Server Components.
React DOM:  React-dom contains features that are only supported for web applications (which run in the browser DOM environment). This section is broken into the following: Hooks - Hooks for web applications which run in the browser DOM environment. Components - React supports all of the browser built-in HTML and SVG components. APIs - The react-dom package contains methods supported only in web applications. Client APIs - The react-dom/client APIs let you render React components on the client (in the browser). Server APIs - The react-dom/server APIs let you render React components to HTML on the server.
"Rules of React:  React has idioms — or rules — for how to express patterns in a way that is easy to understand and yields high-quality applications: Components and Hooks must be pure – Purity makes your code easier to understand, debug, and allows React to automatically optimize your components and hooks correctly. React calls Components and Hooks – React is responsible for rendering components and hooks when necessary to optimize the user experience. Rules of Hooks – Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called."
"Legacy APIs:  Legacy APIs - Exported from the react package, but not recommended for use in newly written code."
"State Hooks:  State lets a component “remember” information like user input. For example, a form component can use state to store the input value, while an image gallery component can use state to store the selected image index. To add state to a component, use one of these Hooks: useState declares a state variable that you can update directly. useReducer declares a state variable with the update logic inside a reducer function.

##Code##
function ImageGallery() {  const [index, setIndex] = useState(0);  // ...
##Code##"
"Context Hooks:  Context lets a component receive information from distant parents without passing it as props. For example, your app’s top-level component can pass the current UI theme to all components below, no matter how deep. useContext reads and subscribes to a context.

##Code##
function Button() {  const theme = useContext(ThemeContext);  // ...
##Code##"
"Ref Hooks:  Refs let a component hold some information that isn’t used for rendering, like a DOM node or a timeout ID. Unlike with state, updating a ref does not re-render your component. Refs are an “escape hatch” from the React paradigm. They are useful when you need to work with non-React systems, such as the built-in browser APIs. useRef declares a ref. You can hold any value in it, but most often it’s used to hold a DOM node. useImperativeHandle lets you customize the ref exposed by your component. This is rarely used.

##Code##
function Form() {  const inputRef = useRef(null);  // ...
##Code##"
"Effect Hooks:  Effects let a component connect to and synchronize with external systems. This includes dealing with network, browser DOM, animations, widgets written using a different UI library, and other non-React code. useEffect connects a component to an external system.

##Code##
function ChatRoom({ roomId }) {  useEffect(() => {    const connection = createConnection(roomId);    connection.connect();    return () => connection.disconnect();  }, [roomId]);  // ...
##Code##
 Effects are an “escape hatch” from the React paradigm. Don’t use Effects to orchestrate the data flow of your application. If you’re not interacting with an external system, you might not need an Effect. There are two rarely used variations of useEffect with differences in timing: useLayoutEffect fires before the browser repaints the screen. You can measure layout here. useInsertionEffect fires before React makes changes to the DOM. Libraries can insert dynamic CSS here."
"Performance Hooks:  A common way to optimize re-rendering performance is to skip unnecessary work. For example, you can tell React to reuse a cached calculation or to skip a re-render if the data has not changed since the previous render. To skip calculations and unnecessary re-rendering, use one of these Hooks: useMemo lets you cache the result of an expensive calculation. useCallback lets you cache a function definition before passing it down to an optimized component.

##Code##
function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}
##Code##
 Sometimes, you can’t skip re-rendering because the screen actually needs to update. In that case, you can improve performance by separating blocking updates that must be synchronous (like typing into an input) from non-blocking updates which don’t need to block the user interface (like updating a chart). To prioritize rendering, use one of these Hooks: useTransition lets you mark a state transition as non-blocking and allow other updates to interrupt it. useDeferredValue lets you defer updating a non-critical part of the UI and let other parts update first."
"Resource Hooks:  Resources can be accessed by a component without having them as part of their state. For example, a component can read a message from a Promise or read styling information from a context. To read a value from a resource, use this Hook: use lets you read the value of a resource like a Promise or context.

##Code##
function MessageComponent({ messagePromise }) {  const message = use(messagePromise);  const theme = use(ThemeContext);  // ...}
##Code##"
Other Hooks:  These Hooks are mostly useful to library authors and aren’t commonly used in the application code. useDebugValue lets you customize the label React DevTools displays for your custom Hook. useId lets a component associate a unique ID with itself. Typically used with accessibility APIs. useSyncExternalStore lets a component subscribe to an external store.
Your own Hooks:  You can also define your own custom Hooks as JavaScript functions.
"Reference:  Call use in your component to read the value of a resource like a Promise or context.

##Code##
import { use } from 'react';function MessageComponent({ messagePromise }) {  const message = use(messagePromise);  const theme = use(ThemeContext);  // ...
##Code##
 Unlike all other React Hooks, use can be called within loops and conditional statements like if. Like other React Hooks, the function that calls use must be a Component or Hook. When called with a Promise, the use Hook integrates with Suspense and error boundaries. The component calling use suspends while the Promise passed to use is pending. If the component that calls use is wrapped in a Suspense boundary, the fallback will be displayed. Once the Promise is resolved, the Suspense fallback is replaced by the rendered components using the data returned by the use Hook. If the Promise passed to use is rejected, the fallback of the nearest Error Boundary will be displayed. See more examples below. resource: this is the source of the data you want to read a value from. A resource can be a Promise or a context. The use Hook returns the value that was read from the resource like the resolved value of a Promise or context. The use Hook must be called inside a Component or a Hook. When fetching data in a Server Component, prefer async and await over use. async and await pick up rendering from the point where await was invoked, whereas use re-renders the component after the data is resolved. Prefer creating Promises in Server Components and passing them to Client Components over creating Promises in Client Components. Promises created in Client Components are recreated on every render. Promises passed from a Server Component to a Client Component are stable across re-renders. See this example."
"Usage:  When a context is passed to use, it works similarly to useContext. While useContext must be called at the top level of your component, use can be called inside conditionals like if and loops like for. use is preferred over useContext because it is more flexible.

##Code##
import { use } from 'react';function Button() {  const theme = use(ThemeContext);  // ...
##Code##
 use returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider.

##Code##
function MyPage() {  return (    <ThemeContext.Provider value=""dark"">      <Form />    </ThemeContext.Provider>  );}function Form() {  // ... renders buttons inside ...}
##Code##
 It doesn’t matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls use(ThemeContext), it will receive ""dark"" as the value. Unlike useContext, use can be called in conditionals and loops like if.

##Code##
function HorizontalRule({ show }) {  if (show) {    const theme = use(ThemeContext);    return <hr className={theme} />;  }  return false;}
##Code##
 use is called from inside a if statement, allowing you to conditionally read values from a Context."
"Troubleshooting:  You are either calling use outside of a React component or Hook function, or calling use in a try–catch block. If you are calling use inside a try–catch block, wrap your component in an error boundary, or call the Promise’s catch to catch the error and resolve the Promise with another value. See these examples. If you are calling use outside a React component or Hook function, move the use call to a React component or Hook function.

##Code##
function MessageComponent({messagePromise}) {  function download() {    // ❌ the function calling `use` is not a Component or Hook    const message = use(messagePromise);    // ...
##Code##
 Instead, call use outside any component closures, where the function that calls use is a component or Hook.

##Code##
function MessageComponent({messagePromise}) {  // ✅ `use` is being called from a component.   const message = use(messagePromise);  // ...
##Code##"
"Reference:  Call useCallback at the top level of your component to cache a function definition between re-renders:

##Code##
import { useCallback } from 'react';export default function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);
##Code##
 See more examples below. fn: The function value that you want to cache. It can take any arguments and return any values. React will return (not call!) your function back to you during the initial render. On next renders, React will give you the same function again if the dependencies have not changed since the last render. Otherwise, it will give you the function that you have passed during the current render, and store it in case it can be reused later. React will not call your function. The function is returned to you so you can decide when and whether to call it. dependencies: The list of all reactive values referenced inside of the fn code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. On the initial render, useCallback returns the fn function you have passed. During subsequent renders, it will either return an already stored fn function from the last render (if the dependencies haven’t changed), or return the fn function you have passed during this render. useCallback is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it. React will not throw away the cached function unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should match your expectations if you rely on useCallback as a performance optimization. Otherwise, a state variable or a ref may be more appropriate."
"Usage:  When you optimize rendering performance, you will sometimes need to cache the functions that you pass to child components. Let’s first look at the syntax for how to do this, and then see in which cases it’s useful. To cache a function between re-renders of your component, wrap its definition into the useCallback Hook:

##Code##
import { useCallback } from 'react';function ProductPage({ productId, referrer, theme }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]);  // ...
##Code##
 You need to pass two things to useCallback: On the initial render, the returned function you’ll get from useCallback will be the function you passed. On the following renders, React will compare the dependencies with the dependencies you passed during the previous render. If none of the dependencies have changed (compared with Object.is), useCallback will return the same function as before. Otherwise, useCallback will return the function you passed on this render. In other words, useCallback caches a function between re-renders until its dependencies change. Let’s walk through an example to see when this is useful. Say you’re passing a handleSubmit function down from the ProductPage to the ShippingForm component:

##Code##
function ProductPage({ productId, referrer, theme }) {  // ...  return (    <div className={theme}>      <ShippingForm onSubmit={handleSubmit} />    </div>  );
##Code##
 You’ve noticed that toggling the theme prop freezes the app for a moment, but if you remove <ShippingForm /> from your JSX, it feels fast. This tells you that it’s worth trying to optimize the ShippingForm component. By default, when a component re-renders, React re-renders all of its children recursively. This is why, when ProductPage re-renders with a different theme, the ShippingForm component also re-renders. This is fine for components that don’t require much calculation to re-render. But if you verified a re-render is slow, you can tell ShippingForm to skip re-rendering when its props are the same as on last render by wrapping it in memo:

##Code##
import { memo } from 'react';const ShippingForm = memo(function ShippingForm({ onSubmit }) {  // ...});
##Code##
 With this change, ShippingForm will skip re-rendering if all of its props are the same as on the last render. This is when caching a function becomes important! Let’s say you defined handleSubmit without useCallback:

##Code##
function ProductPage({ productId, referrer, theme }) {  // Every time the theme changes, this will be a different function...  function handleSubmit(orderDetails) {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }    return (    <div className={theme}>      {/* ... so ShippingForm's props will never be the same, and it will re-render every time */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}
##Code##
 In JavaScript, a function () {} or () => {} always creates a different function, similar to how the {} object literal always creates a new object. Normally, this wouldn’t be a problem, but it means that ShippingForm props will never be the same, and your memo optimization won’t work. This is where useCallback comes in handy:

##Code##
function ProductPage({ productId, referrer, theme }) {  // Tell React to cache your function between re-renders...  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ...so as long as these dependencies don't change...  return (    <div className={theme}>      {/* ...ShippingForm will receive the same props and can skip re-rendering */}      <ShippingForm onSubmit={handleSubmit} />    </div>  );}
##Code##
 By wrapping handleSubmit in useCallback, you ensure that it’s the same function between the re-renders (until dependencies change). You don’t have to wrap a function in useCallback unless you do it for some specific reason. In this example, the reason is that you pass it to a component wrapped in memo, and this lets it skip re-rendering. There are other reasons you might need useCallback which are described further on this page."
"Troubleshooting:  Make sure you’ve specified the dependency array as a second argument! If you forget the dependency array, useCallback will return a new function every time:

##Code##
function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }); // 🔴 Returns a new function every time: no dependency array  // ...
##Code##
 This is the corrected version passing the dependency array as a second argument:

##Code##
function ProductPage({ productId, referrer }) {  const handleSubmit = useCallback((orderDetails) => {    post('/product/' + productId + '/buy', {      referrer,      orderDetails,    });  }, [productId, referrer]); // ✅ Does not return a new function unnecessarily  // ...
##Code##
 If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:

##Code##
const handleSubmit = useCallback((orderDetails) => {    // ..  }, [productId, referrer]);  console.log([productId, referrer]);
##Code##
 You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:

##Code##
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
##Code##
 When you find which dependency is breaking memoization, either find a way to remove it, or memoize it as well. Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can’t call useCallback in a loop:

##Code##
function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useCallback in a loop like this:        const handleClick = useCallback(() => {          sendReport(item)        }, [item]);        return (          <figure key={item.id}>            <Chart onClick={handleClick} />          </figure>        );      })}    </article>  );}
##Code##
 Instead, extract a component for an individual item, and put useCallback there:

##Code##
function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useCallback at the top level:  const handleClick = useCallback(() => {    sendReport(item)  }, [item]);  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );}
##Code##
 Alternatively, you could remove useCallback in the last snippet and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:

##Code##
function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  function handleClick() {    sendReport(item);  }  return (    <figure>      <Chart onClick={handleClick} />    </figure>  );});
##Code##"
"Reference:  Call useContext at the top level of your component to read and subscribe to context.

##Code##
import { useContext } from 'react';function MyComponent() {  const theme = useContext(ThemeContext);  // ...
##Code##
 See more examples below. SomeContext: The context that you’ve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. useContext returns the context value for the calling component. It is determined as the value passed to the closest SomeContext.Provider above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is always up-to-date. React automatically re-renders components that read some context if it changes. useContext() call in a component is not affected by providers returned from the same component. The corresponding <Context.Provider> needs to be above the component doing the useContext() call. React automatically re-renders all the children that use a particular context starting from the provider that receives a different value. The previous and the next values are compared with the Object.is comparison. Skipping re-renders with memo does not prevent the children receiving fresh context values. If your build system produces duplicates modules in the output (which can happen with symlinks), this can break context. Passing something via context only works if SomeContext that you use to provide context and SomeContext that you use to read it are exactly the same object, as determined by a === comparison."
"Usage:  Call useContext at the top level of your component to read and subscribe to context.

##Code##
import { useContext } from 'react';function Button() {  const theme = useContext(ThemeContext);  // ...
##Code##
 useContext returns the context value for the context you passed. To determine the context value, React searches the component tree and finds the closest context provider above for that particular context. To pass context to a Button, wrap it or one of its parent components into the corresponding context provider:

##Code##
function MyPage() {  return (    <ThemeContext.Provider value=""dark"">      <Form />    </ThemeContext.Provider>  );}function Form() {  // ... renders buttons inside ...}
##Code##
 It doesn’t matter how many layers of components there are between the provider and the Button. When a Button anywhere inside of Form calls useContext(ThemeContext), it will receive ""dark"" as the value."
"Troubleshooting:  There are a few common ways that this can happen: You might have a provider without a value in the tree:

##Code##
// 🚩 Doesn't work: no value prop<ThemeContext.Provider>   <Button /></ThemeContext.Provider>
##Code##
 If you forget to specify value, it’s like passing value={undefined}. You may have also mistakingly used a different prop name by mistake:

##Code##
// 🚩 Doesn't work: prop should be called ""value""<ThemeContext.Provider theme={theme}>   <Button /></ThemeContext.Provider>
##Code##
 In both of these cases you should see a warning from React in the console. To fix them, call the prop value:

##Code##
// ✅ Passing the value prop<ThemeContext.Provider value={theme}>   <Button /></ThemeContext.Provider>
##Code##
 Note that the default value from your createContext(defaultValue) call is only used if there is no matching provider above at all. If there is a <SomeContext.Provider value={undefined}> component somewhere in the parent tree, the component calling useContext(SomeContext) will receive undefined as the context value."
"Reference:  Call useDebugValue at the top level of your custom Hook to display a readable debug value:

##Code##
import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}
##Code##
 See more examples below. value: The value you want to display in React DevTools. It can have any type. optional format: A formatting function. When the component is inspected, React DevTools will call the formatting function with the value as the argument, and then display the returned formatted value (which may have any type). If you don’t specify the formatting function, the original value itself will be displayed. useDebugValue does not return anything."
"Usage:  Call useDebugValue at the top level of your custom Hook to display a readable debug value for React DevTools.

##Code##
import { useDebugValue } from 'react';function useOnlineStatus() {  // ...  useDebugValue(isOnline ? 'Online' : 'Offline');  // ...}
##Code##
 This gives components calling useOnlineStatus a label like OnlineStatus: ""Online"" when you inspect them: Without the useDebugValue call, only the underlying data (in this example, true) would be displayed."
"Reference:  Call useDeferredValue at the top level of your component to get a deferred version of that value.

##Code##
import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}
##Code##
 See more examples below. value: The value you want to defer. It can have any type. During the initial render, the returned deferred value will be the same as the value you provided. During updates, React will first attempt a re-render with the old value (so it will return the old value), and then try another re-render in the background with the new value (so it will return the updated value). The values you pass to useDeferredValue should either be primitive values (like strings and numbers) or objects created outside of rendering. If you create a new object during rendering and immediately pass it to useDeferredValue, it will be different on every render, causing unnecessary background re-renders. When useDeferredValue receives a different value (compared with Object.is), in addition to the current render (when it still uses the previous value), it schedules a re-render in the background with the new value. The background re-render is interruptible: if there’s another update to the value, React will restart the background re-render from scratch. For example, if the user is typing into an input faster than a chart receiving its deferred value can re-render, the chart will only re-render after the user stops typing. useDeferredValue is integrated with <Suspense>. If the background update caused by a new value suspends the UI, the user will not see the fallback. They will see the old deferred value until the data loads. useDeferredValue does not by itself prevent extra network requests. There is no fixed delay caused by useDeferredValue itself. As soon as React finishes the original re-render, React will immediately start working on the background re-render with the new deferred value. Any updates caused by events (like typing) will interrupt the background re-render and get prioritized over it. The background re-render caused by useDeferredValue does not fire Effects until it’s committed to the screen. If the background re-render suspends, its Effects will run after the data loads and the UI updates."
"Usage:  Call useDeferredValue at the top level of your component to defer updating some part of your UI.

##Code##
import { useState, useDeferredValue } from 'react';function SearchPage() {  const [query, setQuery] = useState('');  const deferredQuery = useDeferredValue(query);  // ...}
##Code##
 During the initial render, the deferred value will be the same as the value you provided. During updates, the deferred value will “lag behind” the latest value. In particular, React will first re-render without updating the deferred value, and then try to re-render with the newly received value in the background. Let’s walk through an example to see when this is useful. In this example, the SearchResults component suspends while fetching the search results. Try typing ""a"", waiting for the results, and then editing it to ""ab"". The results for ""a"" get replaced by the loading fallback."
"Reference:  Call useEffect at the top level of your component to declare an Effect:

##Code##
import { useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);  // ...}
##Code##
 See more examples below. setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. After your component is removed from the DOM, React will run your cleanup function. optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. See the difference between passing an array of dependencies, an empty array, and no dependencies at all. useEffect returns undefined. useEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it. If you’re not trying to synchronize with some external system, you probably don’t need an Effect. When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function. If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect. If your Effect wasn’t caused by an interaction (like a click), React will generally let the browser paint the updated screen first before running your Effect. If your Effect is doing something visual (for example, positioning a tooltip), and the delay is noticeable (for example, it flickers), replace useEffect with useLayoutEffect. Even if your Effect was caused by an interaction (like a click), the browser may repaint the screen before processing the state updates inside your Effect. Usually, that’s what you want. However, if you must block the browser from repainting the screen, you need to replace useEffect with useLayoutEffect. Effects only run on the client. They don’t run during server rendering."
"Usage:  Some components need to stay connected to the network, some browser API, or a third-party library, while they are displayed on the page. These systems aren’t controlled by React, so they are called external. To connect your component to some external system, call useEffect at the top level of your component:

##Code##
import { useEffect } from 'react';import { createConnection } from './chat.js';function ChatRoom({ roomId }) {  const [serverUrl, setServerUrl] = useState('https://localhost:1234');  useEffect(() => {  	const connection = createConnection(serverUrl, roomId);    connection.connect();  	return () => {      connection.disconnect();  	};  }, [serverUrl, roomId]);  // ...}
##Code##
 You need to pass two arguments to useEffect: React calls your setup and cleanup functions whenever it’s necessary, which may happen multiple times: Let’s illustrate this sequence for the example above. When the ChatRoom component above gets added to the page, it will connect to the chat room with the initial serverUrl and roomId. If either serverUrl or roomId change as a result of a re-render (say, if the user picks a different chat room in a dropdown), your Effect will disconnect from the previous room, and connect to the next one. When the ChatRoom component is removed from the page, your Effect will disconnect one last time. To help you find bugs, in development React runs setup and cleanup one extra time before the setup. This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development). See common solutions. Try to write every Effect as an independent process and think about a single setup/cleanup cycle at a time. It shouldn’t matter whether your component is mounting, updating, or unmounting. When your cleanup logic correctly “mirrors” the setup logic, your Effect is resilient to running setup and cleanup as often as needed."
"Troubleshooting:  When Strict Mode is on, in development, React runs setup and cleanup one extra time before the actual setup. This is a stress-test that verifies your Effect’s logic is implemented correctly. If this causes visible issues, your cleanup function is missing some logic. The cleanup function should stop or undo whatever the setup function was doing. The rule of thumb is that the user shouldn’t be able to distinguish between the setup being called once (as in production) and a setup → cleanup → setup sequence (as in development). Read more about how this helps find bugs and how to fix your logic. First, check that you haven’t forgotten to specify the dependency array:

##Code##
useEffect(() => {  // ...}); // 🚩 No dependency array: re-runs after every render!
##Code##
 If you’ve specified the dependency array but your Effect still re-runs in a loop, it’s because one of your dependencies is different on every re-render. You can debug this problem by manually logging your dependencies to the console:

##Code##
useEffect(() => {    // ..  }, [serverUrl, roomId]);  console.log([serverUrl, roomId]);
##Code##
 You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:

##Code##
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
##Code##
 When you find the dependency that is different on every re-render, you can usually fix it in one of these ways: Updating state based on previous state from an Effect Removing unnecessary object dependencies Removing unnecessary function dependencies Reading the latest props and state from an Effect As a last resort (if these methods didn’t help), wrap its creation with useMemo or useCallback (for functions). If your Effect runs in an infinite cycle, these two things must be true: Your Effect is updating some state. That state leads to a re-render, which causes the Effect’s dependencies to change. Before you start fixing the problem, ask yourself whether your Effect is connecting to some external system (like DOM, network, a third-party widget, and so on). Why does your Effect need to set state? Does it synchronize with that external system? Or are you trying to manage your application’s data flow with it? If there is no external system, consider whether removing the Effect altogether would simplify your logic. If you’re genuinely synchronizing with some external system, think about why and under what conditions your Effect should update the state. Has something changed that affects your component’s visual output? If you need to keep track of some data that isn’t used by rendering, a ref (which doesn’t trigger re-renders) might be more appropriate. Verify your Effect doesn’t update the state (and trigger re-renders) more than needed. Finally, if your Effect is updating the state at the right time, but there is still a loop, it’s because that state update leads to one of the Effect’s dependencies changing. Read how to debug dependency changes. The cleanup function runs not only during unmount, but before every re-render with changed dependencies. Additionally, in development, React runs setup+cleanup one extra time immediately after component mounts. If you have cleanup code without corresponding setup code, it’s usually a code smell:

##Code##
useEffect(() => {  // 🔴 Avoid: Cleanup logic without corresponding setup logic  return () => {    doSomething();  };}, []);
##Code##
 Your cleanup logic should be “symmetrical” to the setup logic, and should stop or undo whatever setup did:

##Code##
useEffect(() => {    const connection = createConnection(serverUrl, roomId);    connection.connect();    return () => {      connection.disconnect();    };  }, [serverUrl, roomId]);
##Code##
 Learn how the Effect lifecycle is different from the component’s lifecycle. If your Effect must block the browser from painting the screen, replace useEffect with useLayoutEffect. Note that this shouldn’t be needed for the vast majority of Effects. You’ll only need this if it’s crucial to run your Effect before the browser paint: for example, to measure and position a tooltip before the user sees it."
"Reference:  Call useId at the top level of your component to generate a unique ID:

##Code##
import { useId } from 'react';function PasswordField() {  const passwordHintId = useId();  // ...
##Code##
 See more examples below. useId does not take any parameters. useId returns a unique ID string associated with this particular useId call in this particular component. useId is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it. useId should not be used to generate keys in a list. Keys should be generated from your data."
"Usage:  Call useId at the top level of your component to generate a unique ID:

##Code##
import { useId } from 'react';function PasswordField() {  const passwordHintId = useId();  // ...
##Code##
 You can then pass the generated ID to different attributes:

##Code##
<>  <input type=""password"" aria-describedby={passwordHintId} />  <p id={passwordHintId}></>
##Code##
 Let’s walk through an example to see when this is useful. HTML accessibility attributes like aria-describedby let you specify that two tags are related to each other. For example, you can specify that an element (like an input) is described by another element (like a paragraph). In regular HTML, you would write it like this:

##Code##
<label>  Password:  <input    type=""password""    aria-describedby=""password-hint""  /></label><p id=""password-hint"">  The password should contain at least 18 characters</p>
##Code##
 However, hardcoding IDs like this is not a good practice in React. A component may be rendered more than once on the page—but IDs have to be unique! Instead of hardcoding an ID, generate a unique ID with useId:

##Code##
import { useId } from 'react';function PasswordField() {  const passwordHintId = useId();  return (    <>      <label>        Password:        <input          type=""password""          aria-describedby={passwordHintId}        />      </label>      <p id={passwordHintId}>        The password should contain at least 18 characters      </p>    </>  );}
##Code##
 Now, even if PasswordField appears multiple times on the screen, the generated IDs won’t clash."
"Reference:  Call useImperativeHandle at the top level of your component to customize the ref handle it exposes:

##Code##
import { forwardRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  useImperativeHandle(ref, () => {    return {      // ... your methods ...    };  }, []);  // ...
##Code##
 See more examples below. ref: The ref you received as the second argument from the forwardRef render function. createHandle: A function that takes no arguments and returns the ref handle you want to expose. That ref handle can have any type. Usually, you will return an object with the methods you want to expose. optional dependencies: The list of all reactive values referenced inside of the createHandle code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If a re-render resulted in a change to some dependency, or if you omitted this argument, your createHandle function will re-execute, and the newly created handle will be assigned to the ref. useImperativeHandle returns undefined."
"Usage:  By default, components don’t expose their DOM nodes to parent components. For example, if you want the parent component of MyInput to have access to the <input> DOM node, you have to opt in with forwardRef:

##Code##
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  return <input {...props} ref={ref} />;});
##Code##
 With the code above, a ref to MyInput will receive the <input> DOM node. However, you can expose a custom value instead. To customize the exposed handle, call useImperativeHandle at the top level of your component:

##Code##
import { forwardRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  useImperativeHandle(ref, () => {    return {      // ... your methods ...    };  }, []);  return <input {...props} />;});
##Code##
 Note that in the code above, the ref is no longer forwarded to the <input>. For example, suppose you don’t want to expose the entire <input> DOM node, but you want to expose two of its methods: focus and scrollIntoView. To do this, keep the real browser DOM in a separate ref. Then use useImperativeHandle to expose a handle with only the methods that you want the parent component to call:

##Code##
import { forwardRef, useRef, useImperativeHandle } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  const inputRef = useRef(null);  useImperativeHandle(ref, () => {    return {      focus() {        inputRef.current.focus();      },      scrollIntoView() {        inputRef.current.scrollIntoView();      },    };  }, []);  return <input {...props} ref={inputRef} />;});
##Code##
 Now, if the parent component gets a ref to MyInput, it will be able to call the focus and scrollIntoView methods on it. However, it will not have full access to the underlying <input> DOM node."
"Reference:  Call useInsertionEffect to insert styles before any Effects fire that may need to read layout:

##Code##
import { useInsertionEffect } from 'react';// Inside your CSS-in-JS libraryfunction useCSS(rule) {  useInsertionEffect(() => {    // ... inject <style> tags here ...  });  return rule;}
##Code##
 See more examples below. setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. When your component is added to the DOM, but before any layout Effects fire, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. When your component is removed from the DOM, React will run your cleanup function. optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison algorithm. If you don’t specify the dependencies at all, your Effect will re-run after every re-render of the component. useInsertionEffect returns undefined. Effects only run on the client. They don’t run during server rendering. You can’t update state from inside useInsertionEffect. By the time useInsertionEffect runs, refs are not attached yet. useInsertionEffect may run either before or after the DOM has been updated. You shouldn’t rely on the DOM being updated at any particular time. Unlike other types of Effects, which fire cleanup for every Effect and then setup for every Effect, useInsertionEffect will fire both cleanup and setup one component at a time. This results in an “interleaving” of the cleanup and setup functions."
"Usage:  Traditionally, you would style React components using plain CSS.

##Code##
// In your JS file:<button className=""success"" />// In your CSS file:.success { color: green; }
##Code##
 Some teams prefer to author styles directly in JavaScript code instead of writing CSS files. This usually requires using a CSS-in-JS library or a tool. There are three common approaches to CSS-in-JS: If you use CSS-in-JS, we recommend a combination of the first two approaches (CSS files for static styles, inline styles for dynamic styles). We don’t recommend runtime <style> tag injection for two reasons: The first problem is not solvable, but useInsertionEffect helps you solve the second problem. Call useInsertionEffect to insert the styles before any layout Effects fire:

##Code##
// Inside your CSS-in-JS librarylet isInserted = new Set();function useCSS(rule) {  useInsertionEffect(() => {    // As explained earlier, we don't recommend runtime injection of <style> tags.    // But if you have to do it, then it's important to do in useInsertionEffect.    if (!isInserted.has(rule)) {      isInserted.add(rule);      document.head.appendChild(getStyleForRule(rule));    }  });  return rule;}function Button() {  const className = useCSS('...');  return <div className={className} />;}
##Code##
 Similarly to useEffect, useInsertionEffect does not run on the server. If you need to collect which CSS rules have been used on the server, you can do it during rendering:

##Code##
let collectedRulesSet = new Set();function useCSS(rule) {  if (typeof window === 'undefined') {    collectedRulesSet.add(rule);  }  useInsertionEffect(() => {    // ...  });  return rule;}
##Code##
 Read more about upgrading CSS-in-JS libraries with runtime injection to useInsertionEffect."
"Reference:  Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:

##Code##
import { useState, useRef, useLayoutEffect } from 'react';function Tooltip() {  const ref = useRef(null);  const [tooltipHeight, setTooltipHeight] = useState(0);  useLayoutEffect(() => {    const { height } = ref.current.getBoundingClientRect();    setTooltipHeight(height);  }, []);  // ...
##Code##
 See more examples below. setup: The function with your Effect’s logic. Your setup function may also optionally return a cleanup function. Before your component is added to the DOM, React will run your setup function. After every re-render with changed dependencies, React will first run the cleanup function (if you provided it) with the old values, and then run your setup function with the new values. Before your component is removed from the DOM, React will run your cleanup function. optional dependencies: The list of all reactive values referenced inside of the setup code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. If you omit this argument, your Effect will re-run after every re-render of the component. useLayoutEffect returns undefined. useLayoutEffect is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a component and move the Effect there. When Strict Mode is on, React will run one extra development-only setup+cleanup cycle before the first real setup. This is a stress-test that ensures that your cleanup logic “mirrors” your setup logic and that it stops or undoes whatever the setup is doing. If this causes a problem, implement the cleanup function. If some of your dependencies are objects or functions defined inside the component, there is a risk that they will cause the Effect to re-run more often than needed. To fix this, remove unnecessary object and function dependencies. You can also extract state updates and non-reactive logic outside of your Effect. Effects only run on the client. They don’t run during server rendering. The code inside useLayoutEffect and all state updates scheduled from it block the browser from repainting the screen. When used excessively, this makes your app slow. When possible, prefer useEffect."
"Usage:  Most components don’t need to know their position and size on the screen to decide what to render. They only return some JSX. Then the browser calculates their layout (position and size) and repaints the screen. Sometimes, that’s not enough. Imagine a tooltip that appears next to some element on hover. If there’s enough space, the tooltip should appear above the element, but if it doesn’t fit, it should appear below. In order to render the tooltip at the right final position, you need to know its height (i.e. whether it fits at the top). To do this, you need to render in two passes: All of this needs to happen before the browser repaints the screen. You don’t want the user to see the tooltip moving. Call useLayoutEffect to perform the layout measurements before the browser repaints the screen:

##Code##
function Tooltip() {  const ref = useRef(null);  const [tooltipHeight, setTooltipHeight] = useState(0); // You don't know real height yet  useLayoutEffect(() => {    const { height } = ref.current.getBoundingClientRect();    setTooltipHeight(height); // Re-render now that you know the real height  }, []);  // ...use tooltipHeight in the rendering logic below...}
##Code##
 Here’s how this works step by step: Hover over the buttons below and see how the tooltip adjusts its position depending on whether it fits:"
"Troubleshooting:  The purpose of useLayoutEffect is to let your component use layout information for rendering: When you or your framework uses server rendering, your React app renders to HTML on the server for the initial render. This lets you show the initial HTML before the JavaScript code loads. The problem is that on the server, there is no layout information. In the earlier example, the useLayoutEffect call in the Tooltip component lets it position itself correctly (either above or below content) depending on the content height. If you tried to render Tooltip as a part of the initial server HTML, this would be impossible to determine. On the server, there is no layout yet! So, even if you rendered it on the server, its position would “jump” on the client after the JavaScript loads and runs. Usually, components that rely on layout information don’t need to render on the server anyway. For example, it probably doesn’t make sense to show a Tooltip during the initial render. It is triggered by a client interaction. However, if you’re running into this problem, you have a few different options: Replace useLayoutEffect with useEffect. This tells React that it’s okay to display the initial render result without blocking the paint (because the original HTML will become visible before your Effect runs). Alternatively, mark your component as client-only. This tells React to replace its content up to the closest <Suspense> boundary with a loading fallback (for example, a spinner or a glimmer) during server rendering. Alternatively, you can render a component with useLayoutEffect only after hydration. Keep a boolean isMounted state that’s initialized to false, and set it to true inside a useEffect call. Your rendering logic can then be like return isMounted ? <RealContent /> : <FallbackContent />. On the server and during the hydration, the user will see FallbackContent which should not call useLayoutEffect. Then React will replace it with RealContent which runs on the client only and can include useLayoutEffect calls. If you synchronize your component with an external data store and rely on useLayoutEffect for different reasons than measuring layout, consider useSyncExternalStore instead which supports server rendering."
"Reference:  Call useMemo at the top level of your component to cache a calculation between re-renders:

##Code##
import { useMemo } from 'react';function TodoList({ todos, tab }) {  const visibleTodos = useMemo(    () => filterTodos(todos, tab),    [todos, tab]  );  // ...}
##Code##
 See more examples below. calculateValue: The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type. React will call your function during the initial render. On next renders, React will return the same value again if the dependencies have not changed since the last render. Otherwise, it will call calculateValue, return its result, and store it so it can be reused later. dependencies: The list of all reactive values referenced inside of the calculateValue code. Reactive values include props, state, and all the variables and functions declared directly inside your component body. If your linter is configured for React, it will verify that every reactive value is correctly specified as a dependency. The list of dependencies must have a constant number of items and be written inline like [dep1, dep2, dep3]. React will compare each dependency with its previous value using the Object.is comparison. On the initial render, useMemo returns the result of calling calculateValue with no arguments. During next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call calculateValue again, and return the result that calculateValue has returned. useMemo is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your calculation function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your calculation function is pure (as it should be), this should not affect your logic. The result from one of the calls will be ignored. React will not throw away the cached value unless there is a specific reason to do that. For example, in development, React throws away the cache when you edit the file of your component. Both in development and in production, React will throw away the cache if your component suspends during the initial mount. In the future, React may add more features that take advantage of throwing away the cache—for example, if React adds built-in support for virtualized lists in the future, it would make sense to throw away the cache for items that scroll out of the virtualized table viewport. This should be fine if you rely on useMemo solely as a performance optimization. Otherwise, a state variable or a ref may be more appropriate."
"Usage:  To cache a calculation between re-renders, wrap it in a useMemo call at the top level of your component:

##Code##
import { useMemo } from 'react';function TodoList({ todos, tab, theme }) {  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...}
##Code##
 You need to pass two things to useMemo: On the initial render, the value you’ll get from useMemo will be the result of calling your calculation. On every subsequent render, React will compare the dependencies with the dependencies you passed during the last render. If none of the dependencies have changed (compared with Object.is), useMemo will return the value you already calculated before. Otherwise, React will re-run your calculation and return the new value. In other words, useMemo caches a calculation result between re-renders until its dependencies change. Let’s walk through an example to see when this is useful. By default, React will re-run the entire body of your component every time that it re-renders. For example, if this TodoList updates its state or receives new props from its parent, the filterTodos function will re-run:

##Code##
function TodoList({ todos, tab, theme }) {  const visibleTodos = filterTodos(todos, tab);  // ...}
##Code##
 Usually, this isn’t a problem because most calculations are very fast. However, if you’re filtering or transforming a large array, or doing some expensive computation, you might want to skip doing it again if data hasn’t changed. If both todos and tab are the same as they were during the last render, wrapping the calculation in useMemo like earlier lets you reuse visibleTodos you’ve already calculated before. This type of caching is called memoization."
"Troubleshooting:  In Strict Mode, React will call some of your functions twice instead of once:

##Code##
function TodoList({ todos, tab }) {  // This component function will run twice for every render.  const visibleTodos = useMemo(() => {    // This calculation will run twice if any of the dependencies change.    return filterTodos(todos, tab);  }, [todos, tab]);  // ...
##Code##
 This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component and calculation functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice and fix the mistake. For example, this impure calculation function mutates an array you received as a prop:

##Code##
const visibleTodos = useMemo(() => {    // 🚩 Mistake: mutating a prop    todos.push({ id: 'last', text: 'Go for a walk!' });    const filtered = filterTodos(todos, tab);    return filtered;  }, [todos, tab]);
##Code##
 React calls your function twice, so you’d notice the todo is added twice. Your calculation shouldn’t change any existing objects, but it’s okay to change any new objects you created during the calculation. For example, if the filterTodos function always returns a different array, you can mutate that array instead:

##Code##
const visibleTodos = useMemo(() => {    const filtered = filterTodos(todos, tab);    // ✅ Correct: mutating an object you created during the calculation    filtered.push({ id: 'last', text: 'Go for a walk!' });    return filtered;  }, [todos, tab]);
##Code##
 Read keeping components pure to learn more about purity. Also, check out the guides on updating objects and updating arrays without mutation. This code doesn’t work:

##Code##
// 🔴 You can't return an object from an arrow function with () => {  const searchOptions = useMemo(() => {    matchMode: 'whole-word',    text: text  }, [text]);
##Code##
 In JavaScript, () => { starts the arrow function body, so the { brace is not a part of your object. This is why it doesn’t return an object, and leads to mistakes. You could fix it by adding parentheses like ({ and }):

##Code##
// This works, but is easy for someone to break again  const searchOptions = useMemo(() => ({    matchMode: 'whole-word',    text: text  }), [text]);
##Code##
 However, this is still confusing and too easy for someone to break by removing the parentheses. To avoid this mistake, write a return statement explicitly:

##Code##
// ✅ This works and is explicit  const searchOptions = useMemo(() => {    return {      matchMode: 'whole-word',      text: text    };  }, [text]);
##Code##
 Make sure you’ve specified the dependency array as a second argument! If you forget the dependency array, useMemo will re-run the calculation every time:

##Code##
function TodoList({ todos, tab }) {  // 🔴 Recalculates every time: no dependency array  const visibleTodos = useMemo(() => filterTodos(todos, tab));  // ...
##Code##
 This is the corrected version passing the dependency array as a second argument:

##Code##
function TodoList({ todos, tab }) {  // ✅ Does not recalculate unnecessarily  const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  // ...
##Code##
 If this doesn’t help, then the problem is that at least one of your dependencies is different from the previous render. You can debug this problem by manually logging your dependencies to the console:

##Code##
const visibleTodos = useMemo(() => filterTodos(todos, tab), [todos, tab]);  console.log([todos, tab]);
##Code##
 You can then right-click on the arrays from different re-renders in the console and select “Store as a global variable” for both of them. Assuming the first one got saved as temp1 and the second one got saved as temp2, you can then use the browser console to check whether each dependency in both arrays is the same:

##Code##
Object.is(temp1[0], temp2[0]); // Is the first dependency the same between the arrays?Object.is(temp1[1], temp2[1]); // Is the second dependency the same between the arrays?Object.is(temp1[2], temp2[2]); // ... and so on for every dependency ...
##Code##
 When you find which dependency breaks memoization, either find a way to remove it, or memoize it as well. Suppose the Chart component is wrapped in memo. You want to skip re-rendering every Chart in the list when the ReportList component re-renders. However, you can’t call useMemo in a loop:

##Code##
function ReportList({ items }) {  return (    <article>      {items.map(item => {        // 🔴 You can't call useMemo in a loop like this:        const data = useMemo(() => calculateReport(item), [item]);        return (          <figure key={item.id}>            <Chart data={data} />          </figure>        );      })}    </article>  );}
##Code##
 Instead, extract a component for each item and memoize data for individual items:

##Code##
function ReportList({ items }) {  return (    <article>      {items.map(item =>        <Report key={item.id} item={item} />      )}    </article>  );}function Report({ item }) {  // ✅ Call useMemo at the top level:  const data = useMemo(() => calculateReport(item), [item]);  return (    <figure>      <Chart data={data} />    </figure>  );}
##Code##
 Alternatively, you could remove useMemo and instead wrap Report itself in memo. If the item prop does not change, Report will skip re-rendering, so Chart will skip re-rendering too:

##Code##
function ReportList({ items }) {  // ...}const Report = memo(function Report({ item }) {  const data = calculateReport(item);  return (    <figure>      <Chart data={data} />    </figure>  );});
##Code##"
"Reference:  useOptimistic is a React Hook that lets you show a different state while an async action is underway. It accepts some state as an argument and returns a copy of that state that can be different during the duration of an async action such as a network request. You provide a function that takes the current state and the input to the action, and returns the optimistic state to be used while the action is pending. This state is called the “optimistic” state because it is usually used to immediately present the user with the result of performing an action, even though the action actually takes time to complete.

##Code##
import { useOptimistic } from 'react';function AppContainer() {  const [optimisticState, addOptimistic] = useOptimistic(    state,    // updateFn    (currentState, optimisticValue) => {      // merge and return new state      // with optimistic value    }  );}
##Code##
 See more examples below. state: the value to be returned initially and whenever no action is pending. updateFn(currentState, optimisticValue): a function that takes the current state and the optimistic value passed to addOptimistic and returns the resulting optimistic state. It must be a pure function. updateFn takes in two parameters. The currentState and the optimisticValue. The return value will be the merged value of the currentState and optimisticValue. optimisticState: The resulting optimistic state. It is equal to state unless an action is pending, in which case it is equal to the value returned by updateFn. addOptimistic: addOptimistic is the dispatching function to call when you have an optimistic update. It takes one argument, optimisticValue, of any type and will call the updateFn with state and optimisticValue."
"Usage:  The useOptimistic Hook provides a way to optimistically update the user interface before a background operation, like a network request, completes. In the context of forms, this technique helps to make apps feel more responsive. When a user submits a form, instead of waiting for the server’s response to reflect the changes, the interface is immediately updated with the expected outcome. For example, when a user types a message into the form and hits the “Send” button, the useOptimistic Hook allows the message to immediately appear in the list with a “Sending…” label, even before the message is actually sent to a server. This “optimistic” approach gives the impression of speed and responsiveness. The form then attempts to truly send the message in the background. Once the server confirms the message has been received, the “Sending…” label is removed."
"Reference:  Call useReducer at the top level of your component to manage its state with a reducer.

##Code##
import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ...
##Code##
 See more examples below. reducer: The reducer function that specifies how the state gets updated. It must be pure, should take the state and action as arguments, and should return the next state. State and action can be of any types. initialArg: The value from which the initial state is calculated. It can be a value of any type. How the initial state is calculated from it depends on the next init argument. optional init: The initializer function that should return the initial state. If it’s not specified, the initial state is set to initialArg. Otherwise, the initial state is set to the result of calling init(initialArg). useReducer returns an array with exactly two values: useReducer is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your reducer and initializer twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your reducer and initializer are pure (as they should be), this should not affect your logic. The result from one of the calls is ignored. The dispatch function returned by useReducer lets you update the state to a different value and trigger a re-render. You need to pass the action as the only argument to the dispatch function:

##Code##
const [state, dispatch] = useReducer(reducer, { age: 42 });function handleClick() {  dispatch({ type: 'incremented_age' });  // ...
##Code##
 React will set the next state to the result of calling the reducer function you’ve provided with the current state and the action you’ve passed to dispatch. action: The action performed by the user. It can be a value of any type. By convention, an action is usually an object with a type property identifying it and, optionally, other properties with additional information. dispatch functions do not have a return value. The dispatch function only updates the state variable for the next render. If you read the state variable after calling the dispatch function, you will still get the old value that was on the screen before your call. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. React may still need to call your component before ignoring the result, but it shouldn’t affect your code. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync."
"Usage:  Call useReducer at the top level of your component to manage state with a reducer.

##Code##
import { useReducer } from 'react';function reducer(state, action) {  // ...}function MyComponent() {  const [state, dispatch] = useReducer(reducer, { age: 42 });  // ...
##Code##
 useReducer returns an array with exactly two items: To update what’s on the screen, call dispatch with an object representing what the user did, called an action:

##Code##
function handleClick() {  dispatch({ type: 'incremented_age' });}
##Code##
 React will pass the current state and the action to your reducer function. Your reducer will calculate and return the next state. React will store that next state, render your component with it, and update the UI."
"Troubleshooting:  Calling the dispatch function does not change state in the running code:

##Code##
function handleClick() {  console.log(state.age);  // 42  dispatch({ type: 'incremented_age' }); // Request a re-render with 43  console.log(state.age);  // Still 42!  setTimeout(() => {    console.log(state.age); // Also 42!  }, 5000);}
##Code##
 This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the state JavaScript variable in your already-running event handler. If you need to guess the next state value, you can calculate it manually by calling the reducer yourself:

##Code##
const action = { type: 'incremented_age' };dispatch(action);const nextState = reducer(state, action);console.log(state);     // { age: 42 }console.log(nextState); // { age: 43 }
##Code##
 React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:

##Code##
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // 🚩 Wrong: mutating existing object      state.age++;      return state;    }    case 'changed_name': {      // 🚩 Wrong: mutating existing object      state.name = action.nextName;      return state;    }    // ...  }}
##Code##
 You mutated an existing state object and returned it, so React ignored the update. To fix this, you need to ensure that you’re always updating objects in state and updating arrays in state instead of mutating them:

##Code##
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ✅ Correct: creating a new object      return {        ...state,        age: state.age + 1      };    }    case 'changed_name': {      // ✅ Correct: creating a new object      return {        ...state,        name: action.nextName      };    }    // ...  }}
##Code##
 Make sure that every case branch copies all of the existing fields when returning the new state:

##Code##
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      return {        ...state, // Don't forget this!        age: state.age + 1      };    }    // ...
##Code##
 Without ...state above, the returned next state would only contain the age field and nothing else. If your state unexpectedly becomes undefined, you’re likely forgetting to return state in one of the cases, or your action type doesn’t match any of the case statements. To find why, throw an error outside the switch:

##Code##
function reducer(state, action) {  switch (action.type) {    case 'incremented_age': {      // ...    }    case 'edited_name': {      // ...    }  }  throw Error('Unknown action: ' + action.type);}
##Code##
 You can also use a static type checker like TypeScript to catch such mistakes. You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally dispatching an action during render, so your component enters a loop: render, dispatch (which causes a render), render, dispatch (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:

##Code##
// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>
##Code##
 If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific dispatch function call responsible for the error. In Strict Mode, React will call your reducer and initializer functions twice. This shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and reducer functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure reducer function mutates an array in state:

##Code##
function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // 🚩 Mistake: mutating state      state.todos.push({ id: nextId++, text: action.text });      return state;    }    // ...  }}
##Code##
 Because React calls your reducer function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:

##Code##
function reducer(state, action) {  switch (action.type) {    case 'added_todo': {      // ✅ Correct: replacing with new state      return {        ...state,        todos: [          ...state.todos,          { id: nextId++, text: action.text }        ]      };    }    // ...  }}
##Code##
 Now that this reducer function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and reducer functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. Read keeping components pure to learn more."
"Reference:  Call useRef at the top level of your component to declare a ref.

##Code##
import { useRef } from 'react';function MyComponent() {  const intervalRef = useRef(0);  const inputRef = useRef(null);  // ...
##Code##
 See more examples below. initialValue: The value you want the ref object’s current property to be initially. It can be a value of any type. This argument is ignored after the initial render. useRef returns an object with a single property: current: Initially, it’s set to the initialValue you have passed. You can later set it to something else. If you pass the ref object to React as a ref attribute to a JSX node, React will set its current property. On the next renders, useRef will return the same object. You can mutate the ref.current property. Unlike state, it is mutable. However, if it holds an object that is used for rendering (for example, a piece of your state), then you shouldn’t mutate that object. When you change the ref.current property, React does not re-render your component. React is not aware of when you change it because a ref is a plain JavaScript object. Do not write or read ref.current during rendering, except for initialization. This makes your component’s behavior unpredictable. In Strict Mode, React will call your component function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. Each ref object will be created twice, but one of the versions will be discarded. If your component function is pure (as it should be), this should not affect the behavior."
"Usage:  Call useRef at the top level of your component to declare one or more refs.

##Code##
import { useRef } from 'react';function Stopwatch() {  const intervalRef = useRef(0);  // ...
##Code##
 useRef returns a ref object with a single current property initially set to the initial value you provided. On the next renders, useRef will return the same object. You can change its current property to store information and read it later. This might remind you of state, but there is an important difference. Changing a ref does not trigger a re-render. This means refs are perfect for storing information that doesn’t affect the visual output of your component. For example, if you need to store an interval ID and retrieve it later, you can put it in a ref. To update the value inside the ref, you need to manually change its current property:

##Code##
function handleStartClick() {  const intervalId = setInterval(() => {    // ...  }, 1000);  intervalRef.current = intervalId;}
##Code##
 Later, you can read that interval ID from the ref so that you can call clear that interval:

##Code##
function handleStopClick() {  const intervalId = intervalRef.current;  clearInterval(intervalId);}
##Code##
 By using a ref, you ensure that: You can store information between re-renders (unlike regular variables, which reset on every render). Changing it does not trigger a re-render (unlike state variables, which trigger a re-render). The information is local to each copy of your component (unlike the variables outside, which are shared). Changing a ref does not trigger a re-render, so refs are not appropriate for storing information you want to display on the screen. Use state for that instead. Read more about choosing between useRef and useState."
"Troubleshooting:  If you try to pass a ref to your own component like this:

##Code##
const inputRef = useRef(null);return <MyInput ref={inputRef} />;
##Code##
 You might get an error in the console: By default, your own components don’t expose refs to the DOM nodes inside them. To fix this, find the component that you want to get a ref to:

##Code##
export default function MyInput({ value, onChange }) {  return (    <input      value={value}      onChange={onChange}    />  );}
##Code##
 And then wrap it in forwardRef like this:

##Code##
import { forwardRef } from 'react';const MyInput = forwardRef(({ value, onChange }, ref) => {  return (    <input      value={value}      onChange={onChange}      ref={ref}    />  );});export default MyInput;
##Code##
 Then the parent component can get a ref to it. Read more about accessing another component’s DOM nodes."
"Reference:  Call useState at the top level of your component to declare a state variable.

##Code##
import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(28);  const [name, setName] = useState('Taylor');  const [todos, setTodos] = useState(() => createTodos());  // ...
##Code##
 The convention is to name state variables like [something, setSomething] using array destructuring. See more examples below. initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render. If you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example below. useState returns an array with exactly two values: useState is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it. In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored. The set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:

##Code##
const [name, setName] = useState('Edward');function handleClick() {  setName('Taylor');  setAge(a => a + 1);  // ...
##Code##
 nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions. If you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example below. set functions do not have a return value. The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call. If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code. React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync. Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example below. In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the behavior. The result from one of the calls will be ignored."
"Usage:  Call useState at the top level of your component to declare one or more state variables.

##Code##
import { useState } from 'react';function MyComponent() {  const [age, setAge] = useState(42);  const [name, setName] = useState('Taylor');  // ...
##Code##
 The convention is to name state variables like [something, setSomething] using array destructuring. useState returns an array with exactly two items: To update what’s on the screen, call the set function with some next state:

##Code##
function handleClick() {  setName('Robin');}
##Code##
 React will store the next state, render your component again with the new values, and update the UI."
"Troubleshooting:  Calling the set function does not change state in the running code:

##Code##
function handleClick() {  console.log(count);  // 0  setCount(count + 1); // Request a re-render with 1  console.log(count);  // Still 0!  setTimeout(() => {    console.log(count); // Also 0!  }, 5000);}
##Code##
 This is because states behaves like a snapshot. Updating state requests another render with the new state value, but does not affect the count JavaScript variable in your already-running event handler. If you need to use the next state, you can save it in a variable before passing it to the set function:

##Code##
const nextCount = count + 1;setCount(nextCount);console.log(count);     // 0console.log(nextCount); // 1
##Code##
 React will ignore your update if the next state is equal to the previous state, as determined by an Object.is comparison. This usually happens when you change an object or an array in state directly:

##Code##
obj.x = 10;  // 🚩 Wrong: mutating existing objectsetObj(obj); // 🚩 Doesn't do anything
##Code##
 You mutated an existing obj object and passed it back to setObj, so React ignored the update. To fix this, you need to ensure that you’re always replacing objects and arrays in state instead of mutating them:

##Code##
// ✅ Correct: creating a new objectsetObj({  ...obj,  x: 10});
##Code##
 You might get an error that says: Too many re-renders. React limits the number of renders to prevent an infinite loop. Typically, this means that you’re unconditionally setting state during render, so your component enters a loop: render, set state (which causes a render), render, set state (which causes a render), and so on. Very often, this is caused by a mistake in specifying an event handler:

##Code##
// 🚩 Wrong: calls the handler during renderreturn <button onClick={handleClick()}>Click me</button>// ✅ Correct: passes down the event handlerreturn <button onClick={handleClick}>Click me</button>// ✅ Correct: passes down an inline functionreturn <button onClick={(e) => handleClick(e)}>Click me</button>
##Code##
 If you can’t find the cause of this error, click on the arrow next to the error in the console and look through the JavaScript stack to find the specific set function call responsible for the error. In Strict Mode, React will call some of your functions twice instead of once:

##Code##
function TodoList() {  // This component function will run twice for every render.  const [todos, setTodos] = useState(() => {    // This initializer function will run twice during initialization.    return createTodos();  });  function handleClick() {    setTodos(prevTodos => {      // This updater function will run twice for every click.      return [...prevTodos, createTodo()];    });  }  // ...
##Code##
 This is expected and shouldn’t break your code. This development-only behavior helps you keep components pure. React uses the result of one of the calls, and ignores the result of the other call. As long as your component, initializer, and updater functions are pure, this shouldn’t affect your logic. However, if they are accidentally impure, this helps you notice the mistakes. For example, this impure updater function mutates an array in state:

##Code##
setTodos(prevTodos => {  // 🚩 Mistake: mutating state  prevTodos.push(createTodo());});
##Code##
 Because React calls your updater function twice, you’ll see the todo was added twice, so you’ll know that there is a mistake. In this example, you can fix the mistake by replacing the array instead of mutating it:

##Code##
setTodos(prevTodos => {  // ✅ Correct: replacing with new state  return [...prevTodos, createTodo()];});
##Code##
 Now that this updater function is pure, calling it an extra time doesn’t make a difference in behavior. This is why React calling it twice helps you find mistakes. Only component, initializer, and updater functions need to be pure. Event handlers don’t need to be pure, so React will never call your event handlers twice. Read keeping components pure to learn more. You can’t put a function into state like this:

##Code##
const [fn, setFn] = useState(someFunction);function handleClick() {  setFn(someOtherFunction);}
##Code##
 Because you’re passing a function, React assumes that someFunction is an initializer function, and that someOtherFunction is an updater function, so it tries to call them and store the result. To actually store a function, you have to put () => before them in both cases. Then React will store the functions you pass.

##Code##
const [fn, setFn] = useState(() => someFunction);function handleClick() {  setFn(() => someOtherFunction);}
##Code##"
"Reference:  Call useSyncExternalStore at the top level of your component to read a value from an external data store.

##Code##
import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);  // ...}
##Code##
 It returns the snapshot of the data in the store. You need to pass two functions as arguments: See more examples below. subscribe: A function that takes a single callback argument and subscribes it to the store. When the store changes, it should invoke the provided callback. This will cause the component to re-render. The subscribe function should return a function that cleans up the subscription. getSnapshot: A function that returns a snapshot of the data in the store that’s needed by the component. While the store has not changed, repeated calls to getSnapshot must return the same value. If the store changes and the returned value is different (as compared by Object.is), React re-renders the component. optional getServerSnapshot: A function that returns the initial snapshot of the data in the store. It will be used only during server rendering and during hydration of server-rendered content on the client. The server snapshot must be the same between the client and the server, and is usually serialized and passed from the server to the client. If you omit this argument, rendering the component on the server will throw an error. The current snapshot of the store which you can use in your rendering logic. The store snapshot returned by getSnapshot must be immutable. If the underlying store has mutable data, return a new immutable snapshot if the data has changed. Otherwise, return a cached last snapshot. If a different subscribe function is passed during a re-render, React will re-subscribe to the store using the newly passed subscribe function. You can prevent this by declaring subscribe outside the component. If the store is mutated during a non-blocking Transition update, React will fall back to performing that update as blocking. Specifically, for every Transition update, React will call getSnapshot a second time just before applying changes to the DOM. If it returns a different value than when it was called originally, React will restart the update from scratch, this time applying it as a blocking update, to ensure that every component on screen is reflecting the same version of the store. It’s not recommended to suspend a render based on a store value returned by useSyncExternalStore. The reason is that mutations to the external store cannot be marked as non-blocking Transition updates, so they will trigger the nearest Suspense fallback, replacing already-rendered content on screen with a loading spinner, which typically makes a poor UX. For example, the following are discouraged: const LazyProductDetailPage = lazy(() => import('./ProductDetailPage.js'));function ShoppingApp() { const selectedProductId = useSyncExternalStore(...); // ❌ Calling `use` with a Promise dependent on `selectedProductId` const data = use(fetchItem(selectedProductId)) // ❌ Conditionally rendering a lazy component based on `selectedProductId` return selectedProductId != null ? <LazyProductDetailPage /> : <FeaturedProducts />;}"
"Usage:  Most of your React components will only read data from their props, state, and context. However, sometimes a component needs to read some data from some store outside of React that changes over time. This includes: Third-party state management libraries that hold state outside of React. Browser APIs that expose a mutable value and events to subscribe to its changes. Call useSyncExternalStore at the top level of your component to read a value from an external data store.

##Code##
import { useSyncExternalStore } from 'react';import { todosStore } from './todoStore.js';function TodosApp() {  const todos = useSyncExternalStore(todosStore.subscribe, todosStore.getSnapshot);  // ...}
##Code##
 It returns the snapshot of the data in the store. You need to pass two functions as arguments: React will use these functions to keep your component subscribed to the store and re-render it on changes. For example, in the sandbox below, todosStore is implemented as an external store that stores data outside of React. The TodosApp component connects to that external store with the useSyncExternalStore Hook."
"Troubleshooting:  This error means your getSnapshot function returns a new object every time it’s called, for example:

##Code##
function getSnapshot() {  // 🔴 Do not return always different objects from getSnapshot  return {    todos: myStore.todos  };}
##Code##
 React will re-render the component if getSnapshot return value is different from the last time. This is why, if you always return a different value, you will enter an infinite loop and get this error. Your getSnapshot object should only return a different object if something has actually changed. If your store contains immutable data, you can return that data directly:

##Code##
function getSnapshot() {  // ✅ You can return immutable data  return myStore.todos;}
##Code##
 If your store data is mutable, your getSnapshot function should return an immutable snapshot of it. This means it does need to create new objects, but it shouldn’t do this for every single call. Instead, it should store the last calculated snapshot, and return the same snapshot as the last time if the data in the store has not changed. How you determine whether mutable data has changed depends on your mutable store. This subscribe function is defined inside a component so it is different on every re-render:

##Code##
function ChatIndicator() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);    // 🚩 Always a different function, so React will resubscribe on every re-render  function subscribe() {    // ...  }  // ...}
##Code##
 React will resubscribe to your store if you pass a different subscribe function between re-renders. If this causes performance issues and you’d like to avoid resubscribing, move the subscribe function outside:

##Code##
function ChatIndicator() {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);  // ...}// ✅ Always the same function, so React won't need to resubscribefunction subscribe() {  // ...}
##Code##
 Alternatively, wrap subscribe into useCallback to only resubscribe when some argument changes:

##Code##
function ChatIndicator({ userId }) {  const isOnline = useSyncExternalStore(subscribe, getSnapshot);    // ✅ Same function as long as userId doesn't change  const subscribe = useCallback(() => {    // ...  }, [userId]);  // ...}
##Code##"
"Reference:  Call useTransition at the top level of your component to mark some state updates as Transitions.

##Code##
import { useTransition } from 'react';function TabContainer() {  const [isPending, startTransition] = useTransition();  // ...}
##Code##
 See more examples below. useTransition does not take any parameters. useTransition returns an array with exactly two items: The startTransition function returned by useTransition lets you mark a state update as a Transition.

##Code##
function TabContainer() {  const [isPending, startTransition] = useTransition();  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
##Code##
 scope: A function that updates some state by calling one or more set functions. React immediately calls scope with no parameters and marks all state updates scheduled synchronously during the scope function call as Transitions. They will be non-blocking and will not display unwanted loading indicators. startTransition does not return anything. useTransition is a Hook, so it can only be called inside components or custom Hooks. If you need to start a Transition somewhere else (for example, from a data library), call the standalone startTransition instead. You can wrap an update into a Transition only if you have access to the set function of that state. If you want to start a Transition in response to some prop or a custom Hook value, try useDeferredValue instead. The function you pass to startTransition must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as Transitions. A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input update. Transition updates can’t be used to control text inputs. If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release."
"Usage:  Call useTransition at the top level of your component to mark state updates as non-blocking Transitions.

##Code##
import { useState, useTransition } from 'react';function TabContainer() {  const [isPending, startTransition] = useTransition();  // ...}
##Code##
 useTransition returns an array with exactly two items: You can then mark a state update as a Transition like this:

##Code##
function TabContainer() {  const [isPending, startTransition] = useTransition();  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
##Code##
 Transitions let you keep the user interface updates responsive even on slow devices. With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish."
"Troubleshooting:  You can’t use a Transition for a state variable that controls an input:

##Code##
const [text, setText] = useState('');// ...function handleChange(e) {  // ❌ Can't use Transitions for controlled input state  startTransition(() => {    setText(e.target.value);  });}// ...return <input value={text} onChange={handleChange} />;
##Code##
 This is because Transitions are non-blocking, but updating an input in response to the change event should happen synchronously. If you want to run a Transition in response to typing, you have two options: When you wrap a state update in a Transition, make sure that it happens during the startTransition call:

##Code##
startTransition(() => {  // ✅ Setting state *during* startTransition call  setPage('/about');});
##Code##
 The function you pass to startTransition must be synchronous. You can’t mark an update as a Transition like this:

##Code##
startTransition(() => {  // ❌ Setting state *after* startTransition call  setTimeout(() => {    setPage('/about');  }, 1000);});
##Code##
 Instead, you could do this:

##Code##
setTimeout(() => {  startTransition(() => {    // ✅ Setting state *during* startTransition call    setPage('/about');  });}, 1000);
##Code##
 Similarly, you can’t mark an update as a Transition like this:

##Code##
startTransition(async () => {  await someAsyncFunction();  // ❌ Setting state *after* startTransition call  setPage('/about');});
##Code##
 However, this works instead:

##Code##
await someAsyncFunction();startTransition(() => {  // ✅ Setting state *during* startTransition call  setPage('/about');});
##Code##
 You can’t call useTransition outside a component because it’s a Hook. In this case, use the standalone startTransition method instead. It works the same way, but it doesn’t provide the isPending indicator. If you run this code, it will print 1, 2, 3:

##Code##
console.log(1);startTransition(() => {  console.log(2);  setPage('/about');});console.log(3);
##Code##
 It is expected to print 1, 2, 3. The function you pass to startTransition does not get delayed. Unlike with the browser setTimeout, it does not run the callback later. React executes your function immediately, but any state updates scheduled while it is running are marked as Transitions. You can imagine that it works like this:

##Code##
// A simplified version of how React workslet isInsideTransition = false;function startTransition(scope) {  isInsideTransition = true;  scope();  isInsideTransition = false;}function setState() {  if (isInsideTransition) {    // ... schedule a Transition state update ...  } else {    // ... schedule an urgent state update ...  }}
##Code##"
"Built-in components:  <Fragment>, alternatively written as <>...</>, lets you group multiple JSX nodes together. <Profiler> lets you measure rendering performance of a React tree programmatically. <Suspense> lets you display a fallback while the child components are loading. <StrictMode> enables extra development-only checks that help you find bugs early."
Your own components:  You can also define your own components as JavaScript functions.
"Reference:  Wrap elements in <Fragment> to group them together in situations where you need a single element. Grouping elements in Fragment has no effect on the resulting DOM; it is the same as if the elements were not grouped. The empty JSX tag <></> is shorthand for <Fragment></Fragment> in most cases. optional key: Fragments declared with the explicit <Fragment> syntax may have keys. If you want to pass key to a Fragment, you can’t use the <>...</> syntax. You have to explicitly import Fragment from 'react' and render <Fragment key={yourKey}>...</Fragment>. React does not reset state when you go from rendering <><Child /></> to [<Child />] or back, or when you go from rendering <><Child /></> to <Child /> and back. This only works a single level deep: for example, going from <><><Child /></></> to <Child /> resets the state. See the precise semantics here."
"Usage:  Use Fragment, or the equivalent <>...</> syntax, to group multiple elements together. You can use it to put multiple elements in any place where a single element can go. For example, a component can only return one element, but by using a Fragment you can group multiple elements together and then return them as a group:

##Code##
function Post() {  return (    <>      <PostTitle />      <PostBody />    </>  );}
##Code##
 Fragments are useful because grouping elements with a Fragment has no effect on layout or styles, unlike if you wrapped the elements in another container like a DOM element. If you inspect this example with the browser tools, you’ll see that all <h1> and <article> DOM nodes appear as siblings without wrappers around them:"
"Reference:  Wrap a component tree in a <Profiler> to measure its rendering performance.

##Code##
<Profiler id=""App"" onRender={onRender}>  <App /></Profiler>
##Code##
 id: A string identifying the part of the UI you are measuring. onRender: An onRender callback that React calls every time components within the profiled tree update. It receives information about what was rendered and how much time it took. Profiling adds some additional overhead, so it is disabled in the production build by default. To opt into production profiling, you need to enable a special production build with profiling enabled. React will call your onRender callback with information about what was rendered.

##Code##
function onRender(id, phase, actualDuration, baseDuration, startTime, commitTime) {  // Aggregate or log render timings...}
##Code##
 id: The string id prop of the <Profiler> tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers. phase: ""mount"", ""update"" or ""nested-update"". This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or Hooks. actualDuration: The number of milliseconds spent rendering the <Profiler> and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. memo and useMemo). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change. baseDuration: The number of milliseconds estimating how much time it would take to re-render the entire <Profiler> subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare actualDuration against it to see if memoization is working. startTime: A numeric timestamp for when React began rendering the current update. commitTime: A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable."
"Usage:  Wrap the <Profiler> component around a React tree to measure its rendering performance.

##Code##
<App>  <Profiler id=""Sidebar"" onRender={onRender}>    <Sidebar />  </Profiler>  <PageContent /></App>
##Code##
 It requires two props: an id (string) and an onRender callback (function) which React calls any time a component within the tree “commits” an update. You can use multiple <Profiler> components to measure different parts of your application:

##Code##
<App>  <Profiler id=""Sidebar"" onRender={onRender}>    <Sidebar />  </Profiler>  <Profiler id=""Content"" onRender={onRender}>    <Content />  </Profiler></App>
##Code##
 You can also nest <Profiler> components:

##Code##
<App>  <Profiler id=""Sidebar"" onRender={onRender}>    <Sidebar />  </Profiler>  <Profiler id=""Content"" onRender={onRender}>    <Content>      <Profiler id=""Editor"" onRender={onRender}>        <Editor />      </Profiler>      <Preview />    </Content>  </Profiler></App>
##Code##
 Although <Profiler> is a lightweight component, it should be used only when necessary. Each use adds some CPU and memory overhead to an application."
"Reference:  Use StrictMode to enable additional development behaviors and warnings for the component tree inside:

##Code##
import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(  <StrictMode>    <App />  </StrictMode>);
##Code##
 See more examples below. Strict Mode enables the following development-only behaviors: Your components will re-render an extra time to find bugs caused by impure rendering. Your components will re-run Effects an extra time to find bugs caused by missing Effect cleanup. Your components will be checked for usage of deprecated APIs. StrictMode accepts no props. There is no way to opt out of Strict Mode inside a tree wrapped in <StrictMode>. This gives you confidence that all components inside <StrictMode> are checked. If two teams working on a product disagree whether they find the checks valuable, they need to either reach consensus or move <StrictMode> down in the tree."
"Usage:  Strict Mode enables extra development-only checks for the entire component tree inside the <StrictMode> component. These checks help you find common bugs in your components early in the development process. To enable Strict Mode for your entire app, wrap your root component with <StrictMode> when you render it:

##Code##
import { StrictMode } from 'react';import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(  <StrictMode>    <App />  </StrictMode>);
##Code##
 We recommend wrapping your entire app in Strict Mode, especially for newly created apps. If you use a framework that calls createRoot for you, check its documentation for how to enable Strict Mode. Although the Strict Mode checks only run in development, they help you find bugs that already exist in your code but can be tricky to reliably reproduce in production. Strict Mode lets you fix bugs before your users report them. You can also enable Strict Mode for any part of your application:

##Code##
import { StrictMode } from 'react';function App() {  return (    <>      <Header />      <StrictMode>        <main>          <Sidebar />          <Content />        </main>      </StrictMode>      <Footer />    </>  );}
##Code##
 In this example, Strict Mode checks will not run against the Header and Footer components. However, they will run on Sidebar and Content, as well as all of the components inside them, no matter how deep. React assumes that every component you write is a pure function. This means that React components you write must always return the same JSX given the same inputs (props, state, and context). Components breaking this rule behave unpredictably and cause bugs. To help you find accidentally impure code, Strict Mode calls some of your functions (only the ones that should be pure) twice in development. This includes: Your component function body (only top-level logic, so this doesn’t include code inside event handlers) Functions that you pass to useState, set functions, useMemo, or useReducer Some class component methods like constructor, render, shouldComponentUpdate (see the whole list) If a function is pure, running it twice does not change its behavior because a pure function produces the same result every time. However, if a function is impure (for example, it mutates the data it receives), running it twice tends to be noticeable (that’s what makes it impure!) This helps you spot and fix the bug early. Here is an example to illustrate how double rendering in Strict Mode helps you find bugs early. This StoryTray component takes an array of stories and adds one last “Create Story” item at the end:"
"Reference:  children: The actual UI you intend to render. If children suspends while rendering, the Suspense boundary will switch to rendering fallback. fallback: An alternate UI to render in place of the actual UI if it has not finished loading. Any valid React node is accepted, though in practice, a fallback is a lightweight placeholder view, such as a loading spinner or skeleton. Suspense will automatically switch to fallback when children suspends, and back to children when the data is ready. If fallback suspends while rendering, it will activate the closest parent Suspense boundary. React does not preserve any state for renders that got suspended before they were able to mount for the first time. When the component has loaded, React will retry rendering the suspended tree from scratch. If Suspense was displaying content for the tree, but then it suspended again, the fallback will be shown again unless the update causing it was caused by startTransition or useDeferredValue. If React needs to hide the already visible content because it suspended again, it will clean up layout Effects in the content tree. When the content is ready to be shown again, React will fire the layout Effects again. This ensures that Effects measuring the DOM layout don’t try to do this while the content is hidden. React includes under-the-hood optimizations like Streaming Server Rendering and Selective Hydration that are integrated with Suspense. Read an architectural overview and watch a technical talk to learn more."
"Usage:  You can wrap any part of your application with a Suspense boundary:

##Code##
<Suspense fallback={<Loading />}>  <Albums /></Suspense>
##Code##
 React will display your loading fallback until all the code and data needed by the children has been loaded. In the example below, the Albums component suspends while fetching the list of albums. Until it’s ready to render, React switches the closest Suspense boundary above to show the fallback—your Loading component. Then, when the data loads, React hides the Loading fallback and renders the Albums component with data."
"Troubleshooting:  Replacing visible UI with a fallback creates a jarring user experience. This can happen when an update causes a component to suspend, and the nearest Suspense boundary is already showing content to the user. To prevent this from happening, mark the update as non-urgent using startTransition. During a Transition, React will wait until enough data has loaded to prevent an unwanted fallback from appearing:

##Code##
function handleNextPageClick() {  // If this update suspends, don't hide the already displayed content  startTransition(() => {    setCurrentPage(currentPage + 1);  });}
##Code##
 This will avoid hiding existing content. However, any newly rendered Suspense boundaries will still immediately display fallbacks to avoid blocking the UI and let the user see the content as it becomes available. React will only prevent unwanted fallbacks during non-urgent updates. It will not delay a render if it’s the result of an urgent update. You must opt in with an API like startTransition or useDeferredValue. If your router is integrated with Suspense, it should wrap its updates into startTransition automatically."
"Reference:  Call cache outside of any components to create a version of the function with caching.

##Code##
import {cache} from 'react';import calculateMetrics from 'lib/metrics';const getMetrics = cache(calculateMetrics);function Chart({data}) {  const report = getMetrics(data);  // ...}
##Code##
 When getMetrics is first called with data, getMetrics will call calculateMetrics(data) and store the result in cache. If getMetrics is called again with the same data, it will return the cached result instead of calling calculateMetrics(data) again. See more examples below. fn: The function you want to cache results for. fn can take any arguments and return any value. cache returns a cached version of fn with the same type signature. It does not call fn in the process. When calling cachedFn with given arguments, it first checks if a cached result exists in the cache. If a cached result exists, it returns the result. If not, it calls fn with the arguments, stores the result in the cache, and returns the result. The only time fn is called is when there is a cache miss. React will invalidate the cache for all memoized functions for each server request. Each call to cache creates a new function. This means that calling cache with the same function multiple times will return different memoized functions that do not share the same cache. cachedFn will also cache errors. If fn throws an error for certain arguments, it will be cached, and the same error is re-thrown when cachedFn is called with those same arguments. cache is for use in Server Components only."
"Usage:  Use cache to skip duplicate work.

##Code##
import {cache} from 'react';import calculateUserMetrics from 'lib/user';const getUserMetrics = cache(calculateUserMetrics);function Profile({user}) {  const metrics = getUserMetrics(user);  // ...}function TeamReport({users}) {  for (let user in users) {    const metrics = getUserMetrics(user);    // ...  }  // ...}
##Code##
 If the same user object is rendered in both Profile and TeamReport, the two components can share work and only call calculateUserMetrics once for that user. Assume Profile is rendered first. It will call getUserMetrics, and check if there is a cached result. Since it is the first time getUserMetrics is called with that user, there will be a cache miss. getUserMetrics will then call calculateUserMetrics with that user and write the result to cache. When TeamReport renders its list of users and reaches the same user object, it will call getUserMetrics and read the result from cache. To share a snapshot of data between components, call cache with a data-fetching function like fetch. When multiple components make the same data fetch, only one request is made and the data returned is cached and shared across components. All components refer to the same snapshot of data across the server render.

##Code##
import {cache} from 'react';import {fetchTemperature} from './api.js';const getTemperature = cache(async (city) => {	return await fetchTemperature(city);});async function AnimatedWeatherCard({city}) {	const temperature = await getTemperature(city);	// ...}async function MinimalWeatherCard({city}) {	const temperature = await getTemperature(city);	// ...}
##Code##
 If AnimatedWeatherCard and MinimalWeatherCard both render for the same city, they will receive the same snapshot of data from the memoized function. If AnimatedWeatherCard and MinimalWeatherCard supply different city arguments to getTemperature, then fetchTemperature will be called twice and each call site will receive different data. The city acts as a cache key. By caching a long-running data fetch, you can kick off asynchronous work prior to rendering the component.

##Code##
const getUser = cache(async (id) => {  return await db.user.query(id);}async function Profile({id}) {  const user = await getUser(id);  return (    <section>      <img src={user.profilePic} />      <h2>{user.name}</h2>    </section>  );}function Page({id}) {  // ✅ Good: start fetching the user data  getUser(id);  // ... some computational work  return (    <>      <Profile id={id} />    </>  );}
##Code##
 When rendering Page, the component calls getUser but note that it doesn’t use the returned data. This early getUser call kicks off the asynchronous database query that occurs while Page is doing other computational work and rendering children. When rendering Profile, we call getUser again. If the initial getUser call has already returned and cached the user data, when Profile asks and waits for this data, it can simply read from the cache without requiring another remote procedure call. If the initial data request hasn’t been completed, preloading data in this pattern reduces delay in data-fetching."
"Troubleshooting:  See prior mentioned pitfalls Calling different memoized functions will read from different caches. Calling a memoized function outside of a component will not use the cache. If none of the above apply, it may be a problem with how React checks if something exists in cache. If your arguments are not primitives (ex. objects, functions, arrays), ensure you’re passing the same object reference. When calling a memoized function, React will look up the input arguments to see if a result is already cached. React will use shallow equality of the arguments to determine if there is a cache hit.

##Code##
import {cache} from 'react';const calculateNorm = cache((vector) => {  // ...});function MapMarker(props) {  // 🚩 Wrong: props is an object that changes every render.  const length = calculateNorm(props);  // ...}function App() {  return (    <>      <MapMarker x={10} y={10} z={10} />      <MapMarker x={10} y={10} z={10} />    </>  );}
##Code##
 In this case the two MapMarkers look like they’re doing the same work and calling calculateNorm with the same value of {x: 10, y: 10, z:10}. Even though the objects contain the same values, they are not the same object reference as each component creates its own props object. React will call Object.is on the input to verify if there is a cache hit.

##Code##
import {cache} from 'react';const calculateNorm = cache((x, y, z) => {  // ...});function MapMarker(props) {  // ✅ Good: Pass primitives to memoized function  const length = calculateNorm(props.x, props.y, props.z);  // ...}function App() {  return (    <>      <MapMarker x={10} y={10} z={10} />      <MapMarker x={10} y={10} z={10} />    </>  );}
##Code##
 One way to address this could be to pass the vector dimensions to calculateNorm. This works because the dimensions themselves are primitives. Another solution may be to pass the vector object itself as a prop to the component. We’ll need to pass the same object to both component instances.

##Code##
import {cache} from 'react';const calculateNorm = cache((vector) => {  // ...});function MapMarker(props) {  // ✅ Good: Pass the same `vector` object  const length = calculateNorm(props.vector);  // ...}function App() {  const vector = [10, 10, 10];  return (    <>      <MapMarker vector={vector} />      <MapMarker vector={vector} />    </>  );}
##Code##"
"Reference:  Call createContext outside of any components to create a context.

##Code##
import { createContext } from 'react';const ThemeContext = createContext('light');
##Code##
 See more examples below. defaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you don’t have any meaningful default value, specify null. The default value is meant as a “last resort” fallback. It is static and never changes over time. createContext returns a context object. The context object itself does not hold any information. It represents which context other components read or provide. Typically, you will use SomeContext.Provider in components above to specify the context value, and call useContext(SomeContext) in components below to read it. The context object has a few properties: SomeContext.Provider lets you provide the context value to components. SomeContext.Consumer is an alternative and rarely used way to read the context value. Wrap your components into a context provider to specify the value of this context for all components inside:

##Code##
function App() {  const [theme, setTheme] = useState('light');  // ...  return (    <ThemeContext.Provider value={theme}>      <Page />    </ThemeContext.Provider>  );}
##Code##
 value: The value that you want to pass to all the components reading this context inside this provider, no matter how deep. The context value can be of any type. A component calling useContext(SomeContext) inside of the provider receives the value of the innermost corresponding context provider above it. Before useContext existed, there was an older way to read context:

##Code##
function Button() {  // 🟡 Legacy way (not recommended)  return (    <ThemeContext.Consumer>      {theme => (        <button className={theme} />      )}    </ThemeContext.Consumer>  );}
##Code##
 Although this older way still works, but newly written code should read context with useContext() instead:

##Code##
function Button() {  // ✅ Recommended way  const theme = useContext(ThemeContext);  return <button className={theme} />;}
##Code##
 children: A function. React will call the function you pass with the current context value determined by the same algorithm as useContext() does, and render the result you return from this function. React will also re-run this function and update the UI whenever the context from the parent components changes."
"Usage:  Context lets components pass information deep down without explicitly passing props. Call createContext outside any components to create one or more contexts.

##Code##
import { createContext } from 'react';const ThemeContext = createContext('light');const AuthContext = createContext(null);
##Code##
 createContext returns a context object. Components can read context by passing it to useContext():

##Code##
function Button() {  const theme = useContext(ThemeContext);  // ...}function Profile() {  const currentUser = useContext(AuthContext);  // ...}
##Code##
 By default, the values they receive will be the default values you have specified when creating the contexts. However, by itself this isn’t useful because the default values never change. Context is useful because you can provide other, dynamic values from your components:

##Code##
function App() {  const [theme, setTheme] = useState('dark');  const [currentUser, setCurrentUser] = useState({ name: 'Taylor' });  // ...  return (    <ThemeContext.Provider value={theme}>      <AuthContext.Provider value={currentUser}>        <Page />      </AuthContext.Provider>    </ThemeContext.Provider>  );}
##Code##
 Now the Page component and any components inside it, no matter how deep, will “see” the passed context values. If the passed context values change, React will re-render the components reading the context as well. Read more about reading and providing context and see examples. Often, components in different files will need access to the same context. This is why it’s common to declare contexts in a separate file. Then you can use the export statement to make context available for other files:

##Code##
// Contexts.jsimport { createContext } from 'react';export const ThemeContext = createContext('light');export const AuthContext = createContext(null);
##Code##
 Components declared in other files can then use the import statement to read or provide this context:

##Code##
// Button.jsimport { ThemeContext } from './Contexts.js';function Button() {  const theme = useContext(ThemeContext);  // ...}
##Code##


##Code##
// App.jsimport { ThemeContext, AuthContext } from './Contexts.js';function App() {  // ...  return (    <ThemeContext.Provider value={theme}>      <AuthContext.Provider value={currentUser}>        <Page />      </AuthContext.Provider>    </ThemeContext.Provider>  );}
##Code##
 This works similar to importing and exporting components."
"Troubleshooting:  Code like this specifies the default context value:

##Code##
const ThemeContext = createContext('light');
##Code##
 This value never changes. React only uses this value as a fallback if it can’t find a matching provider above. To make context change over time, add state and wrap components in a context provider."
"Reference:  Call forwardRef() to let your component receive a ref and forward it to a child component:

##Code##
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  // ...});
##Code##
 See more examples below. render: The render function for your component. React calls this function with the props and ref that your component received from its parent. The JSX you return will be the output of your component. forwardRef returns a React component that you can render in JSX. Unlike React components defined as plain functions, a component returned by forwardRef is also able to receive a ref prop. In Strict Mode, React will call your render function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your render function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored. forwardRef accepts a render function as an argument. React calls this function with props and ref:

##Code##
const MyInput = forwardRef(function MyInput(props, ref) {  return (    <label>      {props.label}      <input ref={ref} />    </label>  );});
##Code##
 props: The props passed by the parent component. ref: The ref attribute passed by the parent component. The ref can be an object or a function. If the parent component has not passed a ref, it will be null. You should either pass the ref you receive to another component, or pass it to useImperativeHandle. forwardRef returns a React component that you can render in JSX. Unlike React components defined as plain functions, the component returned by forwardRef is able to take a ref prop."
"Usage:  By default, each component’s DOM nodes are private. However, sometimes it’s useful to expose a DOM node to the parent—for example, to allow focusing it. To opt in, wrap your component definition into forwardRef():

##Code##
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  const { label, ...otherProps } = props;  return (    <label>      {label}      <input {...otherProps} />    </label>  );});
##Code##
 You will receive a ref as the second argument after props. Pass it to the DOM node that you want to expose:

##Code##
import { forwardRef } from 'react';const MyInput = forwardRef(function MyInput(props, ref) {  const { label, ...otherProps } = props;  return (    <label>      {label}      <input {...otherProps} ref={ref} />    </label>  );});
##Code##
 This lets the parent Form component access the <input> DOM node exposed by MyInput:

##Code##
function Form() {  const ref = useRef(null);  function handleClick() {    ref.current.focus();  }  return (    <form>      <MyInput label=""Enter your name:"" ref={ref} />      <button type=""button"" onClick={handleClick}>        Edit      </button>    </form>  );}
##Code##
 This Form component passes a ref to MyInput. The MyInput component forwards that ref to the <input> browser tag. As a result, the Form component can access that <input> DOM node and call focus() on it. Keep in mind that exposing a ref to the DOM node inside your component makes it harder to change your component’s internals later. You will typically expose DOM nodes from reusable low-level components like buttons or text inputs, but you won’t do it for application-level components like an avatar or a comment."
"Troubleshooting:  This usually means that you forgot to actually use the ref that you received. For example, this component doesn’t do anything with its ref:

##Code##
const MyInput = forwardRef(function MyInput({ label }, ref) {  return (    <label>      {label}      <input />    </label>  );});
##Code##
 To fix it, pass the ref down to a DOM node or another component that can accept a ref:

##Code##
const MyInput = forwardRef(function MyInput({ label }, ref) {  return (    <label>      {label}      <input ref={ref} />    </label>  );});
##Code##
 The ref to MyInput could also be null if some of the logic is conditional:

##Code##
const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {  return (    <label>      {label}      {showInput && <input ref={ref} />}    </label>  );});
##Code##
 If showInput is false, then the ref won’t be forwarded to any node, and a ref to MyInput will remain empty. This is particularly easy to miss if the condition is hidden inside another component, like Panel in this example:

##Code##
const MyInput = forwardRef(function MyInput({ label, showInput }, ref) {  return (    <label>      {label}      <Panel isExpanded={showInput}>        <input ref={ref} />      </Panel>    </label>  );});
##Code##"
"Reference:  Call lazy outside your components to declare a lazy-loaded React component:

##Code##
import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
##Code##
 See more examples below. load: A function that returns a Promise or another thenable (a Promise-like object with a then method). React will not call load until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved value’s .default as a React component. Both the returned Promise and the Promise’s resolved value will be cached, so React will not call load more than once. If the Promise rejects, React will throw the rejection reason for the nearest Error Boundary to handle. lazy returns a React component you can render in your tree. While the code for the lazy component is still loading, attempting to render it will suspend. Use <Suspense> to display a loading indicator while it’s loading. load receives no parameters. You need to return a Promise or some other thenable (a Promise-like object with a then method). It needs to eventually resolve to an object whose .default property is a valid React component type, such as a function, memo, or a forwardRef component."
"Usage:  Usually, you import components with the static import declaration:

##Code##
import MarkdownPreview from './MarkdownPreview.js';
##Code##
 To defer loading this component’s code until it’s rendered for the first time, replace this import with:

##Code##
import { lazy } from 'react';const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));
##Code##
 This code relies on dynamic import(), which might require support from your bundler or framework. Using this pattern requires that the lazy component you’re importing was exported as the default export. Now that your component’s code loads on demand, you also need to specify what should be displayed while it is loading. You can do this by wrapping the lazy component or any of its parents into a <Suspense> boundary:

##Code##
<Suspense fallback={<Loading />}>  <h2>Preview</h2>  <MarkdownPreview /> </Suspense>
##Code##
 In this example, the code for MarkdownPreview won’t be loaded until you attempt to render it. If MarkdownPreview hasn’t loaded yet, Loading will be shown in its place. Try ticking the checkbox:"
"Troubleshooting:  Do not declare lazy components inside other components:

##Code##
import { lazy } from 'react';function Editor() {  // 🔴 Bad: This will cause all state to be reset on re-renders  const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));  // ...}
##Code##
 Instead, always declare them at the top level of your module:

##Code##
import { lazy } from 'react';// ✅ Good: Declare lazy components outside of your componentsconst MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));function Editor() {  // ...}
##Code##"
"Reference:  Wrap a component in memo to get a memoized version of that component. This memoized version of your component will usually not be re-rendered when its parent component is re-rendered as long as its props have not changed. But React may still re-render it: memoization is a performance optimization, not a guarantee.

##Code##
import { memo } from 'react';const SomeComponent = memo(function SomeComponent(props) {  // ...});
##Code##
 See more examples below. Component: The component that you want to memoize. The memo does not modify this component, but returns a new, memoized component instead. Any valid React component, including functions and forwardRef components, is accepted. optional arePropsEqual: A function that accepts two arguments: the component’s previous props, and its new props. It should return true if the old and new props are equal: that is, if the component will render the same output and behave in the same way with the new props as with the old. Otherwise it should return false. Usually, you will not specify this function. By default, React will compare each prop with Object.is. memo returns a new React component. It behaves the same as the component provided to memo except that React will not always re-render it when its parent is being re-rendered unless its props have changed."
"Usage:  React normally re-renders a component whenever its parent re-renders. With memo, you can create a component that React will not re-render when its parent re-renders so long as its new props are the same as the old props. Such a component is said to be memoized. To memoize a component, wrap it in memo and use the value that it returns in place of your original component:

##Code##
const Greeting = memo(function Greeting({ name }) {  return <h1>Hello, {name}!</h1>;});export default Greeting;
##Code##
 A React component should always have pure rendering logic. This means that it must return the same output if its props, state, and context haven’t changed. By using memo, you are telling React that your component complies with this requirement, so React doesn’t need to re-render as long as its props haven’t changed. Even with memo, your component will re-render if its own state changes or if a context that it’s using changes. In this example, notice that the Greeting component re-renders whenever name is changed (because that’s one of its props), but not when address is changed (because it’s not passed to Greeting as a prop):"
"Troubleshooting:  React compares old and new props by shallow equality: that is, it considers whether each new prop is reference-equal to the old prop. If you create a new object or array each time the parent is re-rendered, even if the individual elements are each the same, React will still consider it to be changed. Similarly, if you create a new function when rendering the parent component, React will consider it to have changed even if the function has the same definition. To avoid this, simplify props or memoize props in the parent component."
"Reference:  The startTransition function lets you mark a state update as a Transition.

##Code##
import { startTransition } from 'react';function TabContainer() {  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
##Code##
 See more examples below. scope: A function that updates some state by calling one or more set functions. React immediately calls scope with no arguments and marks all state updates scheduled synchronously during the scope function call as Transitions. They will be non-blocking and will not display unwanted loading indicators. startTransition does not return anything. startTransition does not provide a way to track whether a Transition is pending. To show a pending indicator while the Transition is ongoing, you need useTransition instead. You can wrap an update into a Transition only if you have access to the set function of that state. If you want to start a Transition in response to some prop or a custom Hook return value, try useDeferredValue instead. The function you pass to startTransition must be synchronous. React immediately executes this function, marking all state updates that happen while it executes as Transitions. If you try to perform more state updates later (for example, in a timeout), they won’t be marked as Transitions. A state update marked as a Transition will be interrupted by other state updates. For example, if you update a chart component inside a Transition, but then start typing into an input while the chart is in the middle of a re-render, React will restart the rendering work on the chart component after handling the input state update. Transition updates can’t be used to control text inputs. If there are multiple ongoing Transitions, React currently batches them together. This is a limitation that will likely be removed in a future release."
"Usage:  You can mark a state update as a Transition by wrapping it in a startTransition call:

##Code##
import { startTransition } from 'react';function TabContainer() {  const [tab, setTab] = useState('about');  function selectTab(nextTab) {    startTransition(() => {      setTab(nextTab);    });  }  // ...}
##Code##
 Transitions let you keep the user interface updates responsive even on slow devices. With a Transition, your UI stays responsive in the middle of a re-render. For example, if the user clicks a tab but then change their mind and click another tab, they can do that without waiting for the first re-render to finish."
"Reference:  Call taintObjectReference with an object to register it with React as something that should not be allowed to be passed to the Client as is:

##Code##
import {experimental_taintObjectReference} from 'react';experimental_taintObjectReference(  'Do not pass ALL environment variables to the client.',  process.env);
##Code##
 See more examples below. message: The message you want to display if the object gets passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if the object gets passed to a Client Component. object: The object to be tainted. Functions and class instances can be passed to taintObjectReference as object. Functions and classes are already blocked from being passed to Client Components but the React’s default error message will be replaced by what you defined in message. When a specific instance of a Typed Array is passed to taintObjectReference as object, any other copies of the Typed Array will not be tainted. experimental_taintObjectReference returns undefined. Recreating or cloning a tainted object creates a new untainted object which may contain sensitive data. For example, if you have a tainted user object, const userInfo = {name: user.name, ssn: user.ssn} or {...user} will create new objects which are not tainted. taintObjectReference only protects against simple mistakes when the object is passed through to a Client Component unchanged."
"Usage:  A Client Component should never accept objects that carry sensitive data. Ideally, the data fetching functions should not expose data that the current user should not have access to. Sometimes mistakes happen during refactoring. To protect against these mistakes happening down the line we can “taint” the user object in our data API.

##Code##
import {experimental_taintObjectReference} from 'react';export async function getUser(id) {  const user = await db`SELECT * FROM users WHERE id = ${id}`;  experimental_taintObjectReference(    'Do not pass the entire user object to the client. ' +      'Instead, pick off the specific properties you need for this use case.',    user,  );  return user;}
##Code##
 Now whenever anyone tries to pass this object to a Client Component, an error will be thrown with the passed in error message instead."
"Reference:  Call taintUniqueValue with a password, token, key or hash to register it with React as something that should not be allowed to be passed to the Client as is:

##Code##
import {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue(  'Do not pass secret keys to the client.',  process,  process.env.SECRET_KEY);
##Code##
 See more examples below. message: The message you want to display if value is passed to a Client Component. This message will be displayed as a part of the Error that will be thrown if value is passed to a Client Component. lifetime: Any object that indicates how long value should be tainted. value will be blocked from being sent to any Client Component while this object still exists. For example, passing globalThis blocks the value for the lifetime of an app. lifetime is typically an object whose properties contains value. value: A string, bigint or TypedArray. value must be a unique sequence of characters or bytes with high entropy such as a cryptographic token, private key, hash, or a long password. value will be blocked from being sent to any Client Component. experimental_taintUniqueValue returns undefined. Deriving new values from tainted values can compromise tainting protection. New values created by uppercasing tainted values, concatenating tainted string values into a larger string, converting tainted values to base64, substringing tainted values, and other similar transformations are not tainted unless you explicitly call taintUniqueValue on these newly created values. Do not use taintUniqueValue to protect low-entropy values such as PIN codes or phone numbers. If any value in a request is controlled by an attacker, they could infer which value is tainted by enumerating all possible values of the secret."
"Usage:  To ensure that sensitive information such as passwords, session tokens, or other unique values do not inadvertently get passed to Client Components, the taintUniqueValue function provides a layer of protection. When a value is tainted, any attempt to pass it to a Client Component will result in an error. The lifetime argument defines the duration for which the value remains tainted. For values that should remain tainted indefinitely, objects like globalThis or process can serve as the lifetime argument. These objects have a lifespan that spans the entire duration of your app’s execution.

##Code##
import {experimental_taintUniqueValue} from 'react';experimental_taintUniqueValue(  'Do not pass a user password to the client.',  globalThis,  process.env.SECRET_KEY);
##Code##
 If the tainted value’s lifespan is tied to a object, the lifetime should be the object that encapsulates the value. This ensures the tainted value remains protected for the lifetime of the encapsulating object.

##Code##
import {experimental_taintUniqueValue} from 'react';export async function getUser(id) {  const user = await db`SELECT * FROM users WHERE id = ${id}`;  experimental_taintUniqueValue(    'Do not pass a user session token to the client.',    user,    user.session.token  );  return user;}
##Code##
 In this example, the user object serves as the lifetime argument. If this object gets stored in a global cache or is accessible by another request, the session token remains tainted."
Source code directives:  'use client' lets you mark what code runs on the client. 'use server' marks server-side functions that can be called from client-side code.
"Reference:  Add 'use client' at the top of a file to mark the module and its transitive dependencies as client code.

##Code##
'use client';import { useState } from 'react';import { formatDate } from './formatters';import Button from './button';export default function RichTextEditor({ timestamp, text }) {  const date = formatDate(timestamp);  // ...  const editButton = <Button />;  // ...}
##Code##
 When a file marked with 'use client' is imported from a Server Component, compatible bundlers will treat the module import as a boundary between server-run and client-run code. As dependencies of RichTextEditor, formatDate and Button will also be evaluated on the client regardless of whether their modules contain a 'use client' directive. Note that a single module may be evaluated on the server when imported from server code and on the client when imported from client code. 'use client' must be at the very beginning of a file, above any imports or other code (comments are OK). They must be written with single or double quotes, but not backticks. When a 'use client' module is imported from another client-rendered module, the directive has no effect. When a component module contains a 'use client' directive, any usage of that component is guaranteed to be a Client Component. However, a component can still be evaluated on the client even if it does not have a 'use client' directive. A component usage is considered a Client Component if it is defined in module with 'use client' directive or when it is a transitive dependency of a module that contains a 'use client' directive. Otherwise, it is a Server Component. Code that is marked for client evaluation is not limited to components. All code that is a part of the Client module sub-tree is sent to and run by the client. When a server evaluated module imports values from a 'use client' module, the values must either be a React component or supported serializable prop values to be passed to a Client Component. Any other use case will throw an exception. In a React app, components are often split into separate files, or modules. For apps that use React Server Components, the app is server-rendered by default. 'use client' introduces a server-client boundary in the module dependency tree, effectively creating a subtree of Client modules. To better illustrate this, consider the following React Server Components app."
Usage:
"Reference:  Add 'use server' at the top of an async function body to mark the function as callable by the client. We call these functions Server Actions.

##Code##
async function addToCart(data) {  'use server';  // ...}
##Code##
 When calling a Server Action on the client, it will make a network request to the server that includes a serialized copy of any arguments passed. If the Server Action returns a value, that value will be serialized and returned to the client. Instead of individually marking functions with 'use server', you can add the directive to the top of a file to mark all exports within that file as Server Actions that can be used anywhere, including imported in client code. 'use server' must be at the very beginning of their function or module; above any other code including imports (comments above directives are OK). They must be written with single or double quotes, not backticks. 'use server' can only be used in server-side files. The resulting Server Actions can be passed to Client Components through props. See supported types for serialization. To import a Server Action from client code, the directive must be used on a module level. Because the underlying network calls are always asynchronous, 'use server' can only be used on async functions. Always treat arguments to Server Actions as untrusted input and authorize any mutations. See security considerations. Server Actions should be called in a Transition. Server Actions passed to <form action> or formAction will automatically be called in a transition. Server Actions are designed for mutations that update server-side state; they are not recommended for data fetching. Accordingly, frameworks implementing Server Actions typically process one action at a time and do not have a way to cache the return value. Arguments to Server Actions are fully client-controlled. For security, always treat them as untrusted input, and make sure to validate and escape arguments as appropriate. In any Server Action, make sure to validate that the logged-in user is allowed to perform that action. As client code calls the Server Action over the network, any arguments passed will need to be serializable. Here are supported types for Server Action arguments: Primitives string number bigint boolean undefined null symbol, only symbols registered in the global Symbol registry via Symbol.for Iterables containing serializable values String Array Map Set TypedArray and ArrayBuffer Date FormData instances Plain objects: those created with object initializers, with serializable properties Functions that are Server Actions Promises Notably, these are not supported: React elements, or JSX Functions, including component functions or any other function that is not a Server Action Classes Objects that are instances of any class (other than the built-ins mentioned) or objects with a null prototype Symbols not registered globally, ex. Symbol('my new symbol') Supported serializable return values are the same as serializable props for a boundary Client Component."
"Usage:  The most common use case of Server Actions will be calling server functions that mutate data. On the browser, the HTML form element is the traditional approach for a user to submit a mutation. With React Server Components, React introduces first-class support for Server Actions in forms. Here is a form that allows a user to request a username.

##Code##
// App.jsasync function requestUsername(formData) {  'use server';  const username = formData.get('username');  // ...}export default function App() {  return (    <form action={requestUsername}>      <input type=""text"" name=""username"" />      <button type=""submit"">Request</button>    </form>  );}
##Code##
 In this example requestUsername is a Server Action passed to a <form>. When a user submits this form, there is a network request to the server function requestUsername. When calling a Server Action in a form, React will supply the form’s FormData as the first argument to the Server Action. By passing a Server Action to the form action, React can progressively enhance the form. This means that forms can be submitted before the JavaScript bundle is loaded. In the username request form, there might be the chance that a username is not available. requestUsername should tell us if it fails or not. To update the UI based on the result of a Server Action while supporting progressive enhancement, use useFormState.

##Code##
// requestUsername.js'use server';export default async function requestUsername(formData) {  const username = formData.get('username');  if (canRequest(username)) {    // ...    return 'successful';  }  return 'failed';}
##Code##


##Code##
// UsernameForm.js'use client';import { useFormState } from 'react-dom';import requestUsername from './requestUsername';function UsernameForm() {  const [returnValue, action] = useFormState(requestUsername, 'n/a');  return (    <>      <form action={action}>        <input type=""text"" name=""username"" />        <button type=""submit"">Request</button>      </form>      <p>Last submission request returned: {returnValue}</p>    </>  );}
##Code##
 Note that like most Hooks, useFormState can only be called in client code. Server Actions are exposed server endpoints and can be called anywhere in client code. When using a Server Action outside of a form, call the Server Action in a Transition, which allows you to display a loading indicator, show optimistic state updates, and handle unexpected errors. Forms will automatically wrap Server Actions in transitions.

##Code##
import incrementLike from './actions';import { useState, useTransition } from 'react';function LikeButton() {  const [isPending, startTransition] = useTransition();  const [likeCount, setLikeCount] = useState(0);  const onClick = () => {    startTransition(async () => {      const currentCount = await incrementLike();      setLikeCount(currentCount);    });  };  return (    <>      <p>Total Likes: {likeCount}</p>      <button onClick={onClick} disabled={isPending}>Like</button>;    </>  );}
##Code##


##Code##
// actions.js'use server';let likeCount = 0;export default async function incrementLike() {  likeCount++;  return likeCount;}
##Code##
 To read a Server Action return value, you’ll need to await the promise returned."
"Form Hooks:  Forms let you create interactive controls for submitting information. To manage forms in your components, use one of these Hooks: useFormStatus allows you to make updates to the UI based on the status of the a form. useFormState allows you to manage state inside a form.

##Code##
function Form({ action }) {  async function increment(n) {    return n + 1;  }  const [count, incrementFormAction] = useFormState(increment, 0);  return (    <form action={action}>      <button formAction={incrementFormAction}>Count: {count}</button>      <Button />    </form>  );}function Button() {  const { pending } = useFormStatus();  return (    <button disabled={pending} type=""submit"">      Submit    </button>  );}
##Code##"
"Reference:  Call useFormState at the top level of your component to create component state that is updated when a form action is invoked. You pass useFormState an existing form action function as well as an initial state, and it returns a new action that you use in your form, along with the latest form state. The latest form state is also passed to the function that you provided.

##Code##
import { useFormState } from ""react-dom"";async function increment(previousState, formData) {  return previousState + 1;}function StatefulForm({}) {  const [state, formAction] = useFormState(increment, 0);  return (    <form>      {state}      <button formAction={formAction}>Increment</button>    </form>  )}
##Code##
 The form state is the value returned by the action when the form was last submitted. If the form has not yet been submitted, it is the initial state that you pass. If used with a Server Action, useFormState allows the server’s response from submitting the form to be shown even before hydration has completed. See more examples below. fn: The function to be called when the form is submitted or button pressed. When the function is called, it will receive the previous state of the form (initially the initialState that you pass, subsequently its previous return value) as its initial argument, followed by the arguments that a form action normally receives. initialState: The value you want the state to be initially. It can be any serializable value. This argument is ignored after the action is first invoked. optional permalink: A string containing the unique page URL that this form modifies. For use on pages with dynamic content (eg: feeds) in conjunction with progressive enhancement: if fn is a server action and the form is submitted before the JavaScript bundle loads, the browser will navigate to the specified permalink URL, rather than the current page’s URL. Ensure that the same form component is rendered on the destination page (including the same action fn and permalink) so that React knows how to pass the state through. Once the form has been hydrated, this parameter has no effect. useFormState returns an array with exactly two values: When used with a framework that supports React Server Components, useFormState lets you make forms interactive before JavaScript has executed on the client. When used without Server Components, it is equivalent to component local state. The function passed to useFormState receives an extra argument, the previous or initial state, as its first argument. This makes its signature different than if it were used directly as a form action without using useFormState."
"Usage:  Call useFormState at the top level of your component to access the return value of an action from the last time a form was submitted.

##Code##
import { useFormState } from 'react-dom';import { action } from './actions.js';function MyComponent() {  const [state, formAction] = useFormState(action, null);  // ...  return (    <form action={formAction}>      {/* ... */}    </form>  );}
##Code##
 useFormState returns an array with exactly two items: When the form is submitted, the action function that you provided will be called. Its return value will become the new current state of the form. The action that you provide will also receive a new first argument, namely the current state of the form. The first time the form is submitted, this will be the initial state you provided, while with subsequent submissions, it will be the return value from the last time the action was called. The rest of the arguments are the same as if useFormState had not been used.

##Code##
function action(currentState, formData) {  // ...  return 'next state';}
##Code##"
"Troubleshooting:  When you wrap an action with useFormState, it gets an extra argument as its first argument. The submitted form data is therefore its second argument instead of its first as it would usually be. The new first argument that gets added is the current state of the form.

##Code##
function action(currentState, formData) {  // ...}
##Code##"
"Reference:  The useFormStatus Hook provides status information of the last form submission.

##Code##
import { useFormStatus } from ""react-dom"";import action from './actions';function Submit() {  const status = useFormStatus();  return <button disabled={status.pending}>Submit</button>}export default function App() {  return (    <form action={action}>      <Submit />    </form>  );}
##Code##
 To get status information, the Submit component must be rendered within a <form>. The Hook returns information like the pending property which tells you if the form is actively submitting. In the above example, Submit uses this information to disable <button> presses while the form is submitting. See more examples below. useFormStatus does not take any parameters. A status object with the following properties: pending: A boolean. If true, this means the parent <form> is pending submission. Otherwise, false. data: An object implementing the FormData interface that contains the data the parent <form> is submitting. If there is no active submission or no parent <form>, it will be null. method: A string value of either 'get' or 'post'. This represents whether the parent <form> is submitting with either a GET or POST HTTP method. By default, a <form> will use the GET method and can be specified by the method property. action: A reference to the function passed to the action prop on the parent <form>. If there is no parent <form>, the property is null. If there is a URI value provided to the action prop, or no action prop specified, status.action will be null. The useFormStatus Hook must be called from a component that is rendered inside a <form>. useFormStatus will only return status information for a parent <form>. It will not return status information for any <form> rendered in that same component or children components."
"Usage:  To display a pending state while a form is submitting, you can call the useFormStatus Hook in a component rendered in a <form> and read the pending property returned. Here, we use the pending property to indicate the form is submitting."
"Troubleshooting:  useFormStatus will only return status information for a parent <form>. If the component that calls useFormStatus is not nested in a <form>, status.pending will always return false. Verify useFormStatus is called in a component that is a child of a <form> element. useFormStatus will not track the status of a <form> rendered in the same component. See Pitfall for more details."
Common components:  All of the built-in browser components support some props and events. Common components (e.g. <div>) This includes React-specific props like ref and dangerouslySetInnerHTML.
Form components:  These built-in browser components accept user input: <input> <select> <textarea> They are special in React because passing the value prop to them makes them controlled.
"Resource and Metadata Components:  These bulit-in browser components let you load external resources or annotate the document with metadata: <link> <meta> <script> <style> <title> They are special in React because React can render them into the document head, suspend while resources are loading, and enact other behaviors that are described on the reference page for each specific component."
"All HTML components:  React supports all built-in browser HTML components. This includes: <aside> <audio> <b> <base> <bdi> <bdo> <blockquote> <body> <br> <button> <canvas> <caption> <cite> <code> <col> <colgroup> <data> <datalist> <dd> <del> <details> <dfn> <dialog> <div> <dl> <dt> <em> <embed> <fieldset> <figcaption> <figure> <footer> <form> <h1> <head> <header> <hgroup> <hr> <html> <i> <iframe> <img> <input> <ins> <kbd> <label> <legend> <li> <link> <main> <map> <mark> <menu> <meta> <meter> <nav> <noscript> <object> <ol> <optgroup> <option> <output> <p> <picture> <pre> <progress> <q> <rp> <rt> <ruby> <s> <samp> <script> <section> <select> <slot> <small> <source> <span> <strong> <style> <sub> <summary> <sup> <table> <tbody> <td> <template> <textarea> <tfoot> <th> <thead> <time> <title> <tr> <track> <u> <ul> <var> <video> <wbr> If you render a tag with a dash, like <my-element>, React will assume you want to render a custom HTML element. In React, rendering custom elements works differently from rendering built-in browser tags: All custom element props are serialized to strings and are always set using attributes. Custom elements accept class rather than className, and for rather than htmlFor. If you render a built-in browser HTML element with an is attribute, it will also be treated as a custom element."
All SVG components:  React supports all built-in browser SVG components. This includes: <a> <animate> <animateMotion> <animateTransform> <circle> <clipPath> <defs> <desc> <discard> <ellipse> <feBlend> <feColorMatrix> <feComponentTransfer> <feComposite> <feConvolveMatrix> <feDiffuseLighting> <feDisplacementMap> <feDistantLight> <feDropShadow> <feFlood> <feFuncA> <feFuncB> <feFuncG> <feFuncR> <feGaussianBlur> <feImage> <feMerge> <feMergeNode> <feMorphology> <feOffset> <fePointLight> <feSpecularLighting> <feSpotLight> <feTile> <feTurbulence> <filter> <foreignObject> <g> <hatch> <hatchpath> <image> <line> <linearGradient> <marker> <mask> <metadata> <mpath> <path> <pattern> <polygon> <polyline> <radialGradient> <rect> <script> <set> <stop> <style> <svg> <switch> <symbol> <text> <textPath> <title> <tspan> <use> <view>
"Reference: 

##Code##
<div className=""wrapper"">Some content</div>
##Code##
 See more examples below. These special React props are supported for all built-in components: children: A React node (an element, a string, a number, a portal, an empty node like null, undefined and booleans, or an array of other React nodes). Specifies the content inside the component. When you use JSX, you will usually specify the children prop implicitly by nesting tags like <div><span /></div>. dangerouslySetInnerHTML: An object of the form { __html: '<p>some html</p>' } with a raw HTML string inside. Overrides the innerHTML property of the DOM node and displays the passed HTML inside. This should be used with extreme caution! If the HTML inside isn’t trusted (for example, if it’s based on user data), you risk introducing an XSS vulnerability. Read more about using dangerouslySetInnerHTML. ref: A ref object from useRef or createRef, or a ref callback function, or a string for legacy refs. Your ref will be filled with the DOM element for this node. Read more about manipulating the DOM with refs. suppressContentEditableWarning: A boolean. If true, suppresses the warning that React shows for elements that both have children and contentEditable={true} (which normally do not work together). Use this if you’re building a text input library that manages the contentEditable content manually. suppressHydrationWarning: A boolean. If you use server rendering, normally there is a warning when the server and the client render different content. In some rare cases (like timestamps), it is very hard or impossible to guarantee an exact match. If you set suppressHydrationWarning to true, React will not warn you about mismatches in the attributes and the content of that element. It only works one level deep, and is intended to be used as an escape hatch. Don’t overuse it. Read about suppressing hydration errors. style: An object with CSS styles, for example { fontWeight: 'bold', margin: 20 }. Similarly to the DOM style property, the CSS property names need to be written as camelCase, for example fontWeight instead of font-weight. You can pass strings or numbers as values. If you pass a number, like width: 100, React will automatically append px (“pixels”) to the value unless it’s a unitless property. We recommend using style only for dynamic styles where you don’t know the style values ahead of time. In other cases, applying plain CSS classes with className is more efficient. Read more about className and style. These standard DOM props are also supported for all built-in components: accessKey: A string. Specifies a keyboard shortcut for the element. Not generally recommended. aria-*: ARIA attributes let you specify the accessibility tree information for this element. See ARIA attributes for a complete reference. In React, all ARIA attribute names are exactly the same as in HTML. autoCapitalize: A string. Specifies whether and how the user input should be capitalized. className: A string. Specifies the element’s CSS class name. Read more about applying CSS styles. contentEditable: A boolean. If true, the browser lets the user edit the rendered element directly. This is used to implement rich text input libraries like Lexical. React warns if you try to pass React children to an element with contentEditable={true} because React will not be able to update its content after user edits. data-*: Data attributes let you attach some string data to the element, for example data-fruit=""banana"". In React, they are not commonly used because you would usually read data from props or state instead. dir: Either 'ltr' or 'rtl'. Specifies the text direction of the element. draggable: A boolean. Specifies whether the element is draggable. Part of HTML Drag and Drop API. enterKeyHint: A string. Specifies which action to present for the enter key on virtual keyboards. htmlFor: A string. For <label> and <output>, lets you associate the label with some control. Same as for HTML attribute. React uses the standard DOM property names (htmlFor) instead of HTML attribute names. hidden: A boolean or a string. Specifies whether the element should be hidden. id: A string. Specifies a unique identifier for this element, which can be used to find it later or connect it with other elements. Generate it with useId to avoid clashes between multiple instances of the same component. is: A string. If specified, the component will behave like a custom element. inputMode: A string. Specifies what kind of keyboard to display (for example, text, number or telephone). itemProp: A string. Specifies which property the element represents for structured data crawlers. lang: A string. Specifies the language of the element. onAnimationEnd: An AnimationEvent handler function. Fires when a CSS animation completes. onAnimationEndCapture: A version of onAnimationEnd that fires in the capture phase. onAnimationIteration: An AnimationEvent handler function. Fires when an iteration of a CSS animation ends, and another one begins. onAnimationIterationCapture: A version of onAnimationIteration that fires in the capture phase. onAnimationStart: An AnimationEvent handler function. Fires when a CSS animation starts. onAnimationStartCapture: onAnimationStart, but fires in the capture phase. onAuxClick: A MouseEvent handler function. Fires when a non-primary pointer button was clicked. onAuxClickCapture: A version of onAuxClick that fires in the capture phase. onBeforeInput: An InputEvent handler function. Fires before the value of an editable element is modified. React does not yet use the native beforeinput event, and instead attempts to polyfill it using other events. onBeforeInputCapture: A version of onBeforeInput that fires in the capture phase. onBlur: A FocusEvent handler function. Fires when an element lost focus. Unlike the built-in browser blur event, in React the onBlur event bubbles. onBlurCapture: A version of onBlur that fires in the capture phase. onClick: A MouseEvent handler function. Fires when the primary button was clicked on the pointing device. onClickCapture: A version of onClick that fires in the capture phase. onCompositionStart: A CompositionEvent handler function. Fires when an input method editor starts a new composition session. onCompositionStartCapture: A version of onCompositionStart that fires in the capture phase. onCompositionEnd: A CompositionEvent handler function. Fires when an input method editor completes or cancels a composition session. onCompositionEndCapture: A version of onCompositionEnd that fires in the capture phase. onCompositionUpdate: A CompositionEvent handler function. Fires when an input method editor receives a new character. onCompositionUpdateCapture: A version of onCompositionUpdate that fires in the capture phase. onContextMenu: A MouseEvent handler function. Fires when the user tries to open a context menu. onContextMenuCapture: A version of onContextMenu that fires in the capture phase. onCopy: A ClipboardEvent handler function. Fires when the user tries to copy something into the clipboard. onCopyCapture: A version of onCopy that fires in the capture phase. onCut: A ClipboardEvent handler function. Fires when the user tries to cut something into the clipboard. onCutCapture: A version of onCut that fires in the capture phase. onDoubleClick: A MouseEvent handler function. Fires when the user clicks twice. Corresponds to the browser dblclick event. onDoubleClickCapture: A version of onDoubleClick that fires in the capture phase. onDrag: A DragEvent handler function. Fires while the user is dragging something. onDragCapture: A version of onDrag that fires in the capture phase. onDragEnd: A DragEvent handler function. Fires when the user stops dragging something. onDragEndCapture: A version of onDragEnd that fires in the capture phase. onDragEnter: A DragEvent handler function. Fires when the dragged content enters a valid drop target. onDragEnterCapture: A version of onDragEnter that fires in the capture phase. onDragOver: A DragEvent handler function. Fires on a valid drop target while the dragged content is dragged over it. You must call e.preventDefault() here to allow dropping. onDragOverCapture: A version of onDragOver that fires in the capture phase. onDragStart: A DragEvent handler function. Fires when the user starts dragging an element. onDragStartCapture: A version of onDragStart that fires in the capture phase. onDrop: A DragEvent handler function. Fires when something is dropped on a valid drop target. onDropCapture: A version of onDrop that fires in the capture phase. onFocus: A FocusEvent handler function. Fires when an element receives focus. Unlike the built-in browser focus event, in React the onFocus event bubbles. onFocusCapture: A version of onFocus that fires in the capture phase. onGotPointerCapture: A PointerEvent handler function. Fires when an element programmatically captures a pointer. onGotPointerCaptureCapture: A version of onGotPointerCapture that fires in the capture phase. onKeyDown: A KeyboardEvent handler function. Fires when a key is pressed. onKeyDownCapture: A version of onKeyDown that fires in the capture phase. onKeyPress: A KeyboardEvent handler function. Deprecated. Use onKeyDown or onBeforeInput instead. onKeyPressCapture: A version of onKeyPress that fires in the capture phase. onKeyUp: A KeyboardEvent handler function. Fires when a key is released. onKeyUpCapture: A version of onKeyUp that fires in the capture phase. onLostPointerCapture: A PointerEvent handler function. Fires when an element stops capturing a pointer. onLostPointerCaptureCapture: A version of onLostPointerCapture that fires in the capture phase. onMouseDown: A MouseEvent handler function. Fires when the pointer is pressed down. onMouseDownCapture: A version of onMouseDown that fires in the capture phase. onMouseEnter: A MouseEvent handler function. Fires when the pointer moves inside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered. onMouseLeave: A MouseEvent handler function. Fires when the pointer moves outside an element. Does not have a capture phase. Instead, onMouseLeave and onMouseEnter propagate from the element being left to the one being entered. onMouseMove: A MouseEvent handler function. Fires when the pointer changes coordinates. onMouseMoveCapture: A version of onMouseMove that fires in the capture phase. onMouseOut: A MouseEvent handler function. Fires when the pointer moves outside an element, or if it moves into a child element. onMouseOutCapture: A version of onMouseOut that fires in the capture phase. onMouseUp: A MouseEvent handler function. Fires when the pointer is released. onMouseUpCapture: A version of onMouseUp that fires in the capture phase. onPointerCancel: A PointerEvent handler function. Fires when the browser cancels a pointer interaction. onPointerCancelCapture: A version of onPointerCancel that fires in the capture phase. onPointerDown: A PointerEvent handler function. Fires when a pointer becomes active. onPointerDownCapture: A version of onPointerDown that fires in the capture phase. onPointerEnter: A PointerEvent handler function. Fires when a pointer moves inside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered. onPointerLeave: A PointerEvent handler function. Fires when a pointer moves outside an element. Does not have a capture phase. Instead, onPointerLeave and onPointerEnter propagate from the element being left to the one being entered. onPointerMove: A PointerEvent handler function. Fires when a pointer changes coordinates. onPointerMoveCapture: A version of onPointerMove that fires in the capture phase. onPointerOut: A PointerEvent handler function. Fires when a pointer moves outside an element, if the pointer interaction is cancelled, and a few other reasons. onPointerOutCapture: A version of onPointerOut that fires in the capture phase. onPointerUp: A PointerEvent handler function. Fires when a pointer is no longer active. onPointerUpCapture: A version of onPointerUp that fires in the capture phase. onPaste: A ClipboardEvent handler function. Fires when the user tries to paste something from the clipboard. onPasteCapture: A version of onPaste that fires in the capture phase. onScroll: An Event handler function. Fires when an element has been scrolled. This event does not bubble. onScrollCapture: A version of onScroll that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside an editable element like an input changes. React extends the onSelect event to work for contentEditable={true} elements as well. In addition, React extends it to fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. onTouchCancel: A TouchEvent handler function. Fires when the browser cancels a touch interaction. onTouchCancelCapture: A version of onTouchCancel that fires in the capture phase. onTouchEnd: A TouchEvent handler function. Fires when one or more touch points are removed. onTouchEndCapture: A version of onTouchEnd that fires in the capture phase. onTouchMove: A TouchEvent handler function. Fires one or more touch points are moved. onTouchMoveCapture: A version of onTouchMove that fires in the capture phase. onTouchStart: A TouchEvent handler function. Fires when one or more touch points are placed. onTouchStartCapture: A version of onTouchStart that fires in the capture phase. onTransitionEnd: A TransitionEvent handler function. Fires when a CSS transition completes. onTransitionEndCapture: A version of onTransitionEnd that fires in the capture phase. onWheel: A WheelEvent handler function. Fires when the user rotates a wheel button. onWheelCapture: A version of onWheel that fires in the capture phase. role: A string. Specifies the element role explicitly for assistive technologies. slot: A string. Specifies the slot name when using shadow DOM. In React, an equivalent pattern is typically achieved by passing JSX as props, for example <Layout left={<Sidebar />} right={<Content />} />. spellCheck: A boolean or null. If explicitly set to true or false, enables or disables spellchecking. tabIndex: A number. Overrides the default Tab button behavior. Avoid using values other than -1 and 0. title: A string. Specifies the tooltip text for the element. translate: Either 'yes' or 'no'. Passing 'no' excludes the element content from being translated. You can also pass custom attributes as props, for example mycustomprop=""someValue"". This can be useful when integrating with third-party libraries. The custom attribute name must be lowercase and must not start with on. The value will be converted to a string. If you pass null or undefined, the custom attribute will be removed. These events fire only for the <form> elements: onReset: An Event handler function. Fires when a form gets reset. onResetCapture: A version of onReset that fires in the capture phase. onSubmit: An Event handler function. Fires when a form gets submitted. onSubmitCapture: A version of onSubmit that fires in the capture phase. These events fire only for the <dialog> elements. Unlike browser events, they bubble in React: onCancel: An Event handler function. Fires when the user tries to dismiss the dialog. onCancelCapture: A version of onCancel that fires in the capture phase. onClose: An Event handler function. Fires when a dialog has been closed. onCloseCapture: A version of onClose that fires in the capture phase. These events fire only for the <details> elements. Unlike browser events, they bubble in React: onToggle: An Event handler function. Fires when the user toggles the details. onToggleCapture: A version of onToggle that fires in the capture phase. These events fire for <img>, <iframe>, <object>, <embed>, <link>, and SVG <image> elements. Unlike browser events, they bubble in React: onLoad: An Event handler function. Fires when the resource has loaded. onLoadCapture: A version of onLoad that fires in the capture phase. onError: An Event handler function. Fires when the resource could not be loaded. onErrorCapture: A version of onError that fires in the capture phase. These events fire for resources like <audio> and <video>. Unlike browser events, they bubble in React: onAbort: An Event handler function. Fires when the resource has not fully loaded, but not due to an error. onAbortCapture: A version of onAbort that fires in the capture phase. onCanPlay: An Event handler function. Fires when there’s enough data to start playing, but not enough to play to the end without buffering. onCanPlayCapture: A version of onCanPlay that fires in the capture phase. onCanPlayThrough: An Event handler function. Fires when there’s enough data that it’s likely possible to start playing without buffering until the end. onCanPlayThroughCapture: A version of onCanPlayThrough that fires in the capture phase. onDurationChange: An Event handler function. Fires when the media duration has updated. onDurationChangeCapture: A version of onDurationChange that fires in the capture phase. onEmptied: An Event handler function. Fires when the media has become empty. onEmptiedCapture: A version of onEmptied that fires in the capture phase. onEncrypted: An Event handler function. Fires when the browser encounters encrypted media. onEncryptedCapture: A version of onEncrypted that fires in the capture phase. onEnded: An Event handler function. Fires when the playback stops because there’s nothing left to play. onEndedCapture: A version of onEnded that fires in the capture phase. onError: An Event handler function. Fires when the resource could not be loaded. onErrorCapture: A version of onError that fires in the capture phase. onLoadedData: An Event handler function. Fires when the current playback frame has loaded. onLoadedDataCapture: A version of onLoadedData that fires in the capture phase. onLoadedMetadata: An Event handler function. Fires when metadata has loaded. onLoadedMetadataCapture: A version of onLoadedMetadata that fires in the capture phase. onLoadStart: An Event handler function. Fires when the browser started loading the resource. onLoadStartCapture: A version of onLoadStart that fires in the capture phase. onPause: An Event handler function. Fires when the media was paused. onPauseCapture: A version of onPause that fires in the capture phase. onPlay: An Event handler function. Fires when the media is no longer paused. onPlayCapture: A version of onPlay that fires in the capture phase. onPlaying: An Event handler function. Fires when the media starts or restarts playing. onPlayingCapture: A version of onPlaying that fires in the capture phase. onProgress: An Event handler function. Fires periodically while the resource is loading. onProgressCapture: A version of onProgress that fires in the capture phase. onRateChange: An Event handler function. Fires when playback rate changes. onRateChangeCapture: A version of onRateChange that fires in the capture phase. onResize: An Event handler function. Fires when video changes size. onResizeCapture: A version of onResize that fires in the capture phase. onSeeked: An Event handler function. Fires when a seek operation completes. onSeekedCapture: A version of onSeeked that fires in the capture phase. onSeeking: An Event handler function. Fires when a seek operation starts. onSeekingCapture: A version of onSeeking that fires in the capture phase. onStalled: An Event handler function. Fires when the browser is waiting for data but it keeps not loading. onStalledCapture: A version of onStalled that fires in the capture phase. onSuspend: An Event handler function. Fires when loading the resource was suspended. onSuspendCapture: A version of onSuspend that fires in the capture phase. onTimeUpdate: An Event handler function. Fires when the current playback time updates. onTimeUpdateCapture: A version of onTimeUpdate that fires in the capture phase. onVolumeChange: An Event handler function. Fires when the volume has changed. onVolumeChangeCapture: A version of onVolumeChange that fires in the capture phase. onWaiting: An Event handler function. Fires when the playback stopped due to temporary lack of data. onWaitingCapture: A version of onWaiting that fires in the capture phase. You cannot pass both children and dangerouslySetInnerHTML at the same time. Some events (like onAbort and onLoad) don’t bubble in the browser, but bubble in React. Instead of a ref object (like the one returned by useRef), you may pass a function to the ref attribute.

##Code##
<div ref={(node) => console.log(node)} />
##Code##
 See an example of using the ref callback. When the <div> DOM node is added to the screen, React will call your ref callback with the DOM node as the argument. When that <div> DOM node is removed, React will call your ref callback with null. React will also call your ref callback whenever you pass a different ref callback. In the above example, (node) => { ... } is a different function on every render. When your component re-renders, the previous function will be called with null as the argument, and the next function will be called with the DOM node. node: A DOM node or null. React will pass you the DOM node when the ref gets attached, and null when the ref gets detached. Unless you pass the same function reference for the ref callback on every render, the callback will get temporarily detached and re-attached during every re-render of the component. Do not return anything from the ref callback. Your event handlers will receive a React event object. It is also sometimes known as a “synthetic event”.

##Code##
<button onClick={e => {  console.log(e); // React event object}} />
##Code##
 It conforms to the same standard as the underlying DOM events, but fixes some browser inconsistencies. Some React events do not map directly to the browser’s native events. For example in onMouseLeave, e.nativeEvent will point to a mouseout event. The specific mapping is not part of the public API and may change in the future. If you need the underlying browser event for some reason, read it from e.nativeEvent. React event objects implement some of the standard Event properties: bubbles: A boolean. Returns whether the event bubbles through the DOM. cancelable: A boolean. Returns whether the event can be canceled. currentTarget: A DOM node. Returns the node to which the current handler is attached in the React tree. defaultPrevented: A boolean. Returns whether preventDefault was called. eventPhase: A number. Returns which phase the event is currently in. isTrusted: A boolean. Returns whether the event was initiated by user. target: A DOM node. Returns the node on which the event has occurred (which could be a distant child). timeStamp: A number. Returns the time when the event occurred. Additionally, React event objects provide these properties: nativeEvent: A DOM Event. The original browser event object. React event objects implement some of the standard Event methods: preventDefault(): Prevents the default browser action for the event. stopPropagation(): Stops the event propagation through the React tree. Additionally, React event objects provide these methods: isDefaultPrevented(): Returns a boolean value indicating whether preventDefault was called. isPropagationStopped(): Returns a boolean value indicating whether stopPropagation was called. persist(): Not used with React DOM. With React Native, call this to read event’s properties after the event. isPersistent(): Not used with React DOM. With React Native, returns whether persist has been called. The values of currentTarget, eventPhase, target, and type reflect the values your React code expects. Under the hood, React attaches event handlers at the root, but this is not reflected in React event objects. For example, e.currentTarget may not be the same as the underlying e.nativeEvent.currentTarget. For polyfilled events, e.type (React event type) may differ from e.nativeEvent.type (underlying type). An event handler type for the CSS animation events.

##Code##
<div  onAnimationStart={e => console.log('onAnimationStart')}  onAnimationIteration={e => console.log('onAnimationIteration')}  onAnimationEnd={e => console.log('onAnimationEnd')}/>
##Code##
 e: A React event object with these extra AnimationEvent properties: animationName elapsedTime pseudoElement An event handler type for the Clipboard API events.

##Code##
<input  onCopy={e => console.log('onCopy')}  onCut={e => console.log('onCut')}  onPaste={e => console.log('onPaste')}/>
##Code##
 e: A React event object with these extra ClipboardEvent properties: clipboardData An event handler type for the input method editor (IME) events.

##Code##
<input  onCompositionStart={e => console.log('onCompositionStart')}  onCompositionUpdate={e => console.log('onCompositionUpdate')}  onCompositionEnd={e => console.log('onCompositionEnd')}/>
##Code##
 e: A React event object with these extra CompositionEvent properties: data An event handler type for the HTML Drag and Drop API events.

##Code##
<>  <div    draggable={true}    onDragStart={e => console.log('onDragStart')}    onDragEnd={e => console.log('onDragEnd')}  >    Drag source  </div>  <div    onDragEnter={e => console.log('onDragEnter')}    onDragLeave={e => console.log('onDragLeave')}    onDragOver={e => { e.preventDefault(); console.log('onDragOver'); }}    onDrop={e => console.log('onDrop')}  >    Drop target  </div></>
##Code##
 e: A React event object with these extra DragEvent properties: dataTransfer It also includes the inherited MouseEvent properties: altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey It also includes the inherited UIEvent properties: detail view An event handler type for the focus events.

##Code##
<input  onFocus={e => console.log('onFocus')}  onBlur={e => console.log('onBlur')}/>
##Code##
 See an example. e: A React event object with these extra FocusEvent properties: relatedTarget It also includes the inherited UIEvent properties: detail view An event handler type for generic events. e: A React event object with no additional properties. An event handler type for the onBeforeInput event.

##Code##
<input onBeforeInput={e => console.log('onBeforeInput')} />
##Code##
 e: A React event object with these extra InputEvent properties: data An event handler type for keyboard events.

##Code##
<input  onKeyDown={e => console.log('onKeyDown')}  onKeyUp={e => console.log('onKeyUp')}/>
##Code##
 See an example. e: A React event object with these extra KeyboardEvent properties: altKey charCode code ctrlKey getModifierState(key) key keyCode locale metaKey location repeat shiftKey which It also includes the inherited UIEvent properties: detail view An event handler type for mouse events.

##Code##
<div  onClick={e => console.log('onClick')}  onMouseEnter={e => console.log('onMouseEnter')}  onMouseOver={e => console.log('onMouseOver')}  onMouseDown={e => console.log('onMouseDown')}  onMouseUp={e => console.log('onMouseUp')}  onMouseLeave={e => console.log('onMouseLeave')}/>
##Code##
 See an example. e: A React event object with these extra MouseEvent properties: altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey It also includes the inherited UIEvent properties: detail view An event handler type for pointer events.

##Code##
<div  onPointerEnter={e => console.log('onPointerEnter')}  onPointerMove={e => console.log('onPointerMove')}  onPointerDown={e => console.log('onPointerDown')}  onPointerUp={e => console.log('onPointerUp')}  onPointerLeave={e => console.log('onPointerLeave')}/>
##Code##
 See an example. e: A React event object with these extra PointerEvent properties: height isPrimary pointerId pointerType pressure tangentialPressure tiltX tiltY twist width It also includes the inherited MouseEvent properties: altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey It also includes the inherited UIEvent properties: detail view An event handler type for touch events.

##Code##
<div  onTouchStart={e => console.log('onTouchStart')}  onTouchMove={e => console.log('onTouchMove')}  onTouchEnd={e => console.log('onTouchEnd')}  onTouchCancel={e => console.log('onTouchCancel')}/>
##Code##
 e: A React event object with these extra TouchEvent properties: altKey ctrlKey changedTouches getModifierState(key) metaKey shiftKey touches targetTouches It also includes the inherited UIEvent properties: detail view An event handler type for the CSS transition events.

##Code##
<div  onTransitionEnd={e => console.log('onTransitionEnd')}/>
##Code##
 e: A React event object with these extra TransitionEvent properties: elapsedTime propertyName pseudoElement An event handler type for generic UI events.

##Code##
<div  onScroll={e => console.log('onScroll')}/>
##Code##
 e: A React event object with these extra UIEvent properties: detail view An event handler type for the onWheel event.

##Code##
<div  onWheel={e => console.log('onWheel')}/>
##Code##
 e: A React event object with these extra WheelEvent properties: deltaMode deltaX deltaY deltaZ It also includes the inherited MouseEvent properties: altKey button buttons ctrlKey clientX clientY getModifierState(key) metaKey movementX movementY pageX pageY relatedTarget screenX screenY shiftKey It also includes the inherited UIEvent properties: detail view"
"Usage:  In React, you specify a CSS class with className. It works like the class attribute in HTML:

##Code##
<img className=""avatar"" />
##Code##
 Then you write the CSS rules for it in a separate CSS file:

##Code##
/* In your CSS */.avatar {  border-radius: 50%;}
##Code##
 React does not prescribe how you add CSS files. In the simplest case, you’ll add a <link> tag to your HTML. If you use a build tool or a framework, consult its documentation to learn how to add a CSS file to your project. Sometimes, the style values depend on data. Use the style attribute to pass some styles dynamically:

##Code##
<img  className=""avatar""  style={{    width: user.imageSize,    height: user.imageSize  }}/>
##Code##
 In the above example, style={{}} is not a special syntax, but a regular {} object inside the style={ } JSX curly braces. We recommend only using the style attribute when your styles depend on JavaScript variables."
"Reference:  To create interactive controls for submitting information, render the built-in browser <form> component.

##Code##
<form action={search}>    <input name=""query"" />    <button type=""submit"">Search</button></form>
##Code##
 See more examples below. <form> supports all common element props. action: a URL or function. When a URL is passed to action the form will behave like the HTML form component. When a function is passed to action the function will handle the form submission. The function passed to action may be async and will be called with a single argument containing the form data of the submitted form. The action prop can be overridden by a formAction attribute on a <button>, <input type=""submit"">, or <input type=""image""> component. When a function is passed to action or formAction the HTTP method will be POST regardless of value of the method prop."
"Usage:  Pass a function to the action prop of form to run the function when the form is submitted. formData will be passed to the function as an argument so you can access the data submitted by the form. This differs from the conventional HTML action, which only accepts URLs."
"Reference:  To display an input, render the built-in browser <input> component.

##Code##
<input name=""myInput"" />
##Code##
 See more examples below. <input> supports all common element props. formAction: A string or function. Overrides the parent <form action> for type=""submit"" and type=""image"". When a URL is passed to action the form will behave like a standard HTML form. When a function is passed to formAction the function will handle the form submission. See <form action>. You can make an input controlled by passing one of these props: checked: A boolean. For a checkbox input or a radio button, controls whether it is selected. value: A string. For a text input, controls its text. (For a radio button, specifies its form data.) When you pass either of them, you must also pass an onChange handler that updates the passed value. These <input> props are only relevant for uncontrolled inputs: defaultChecked: A boolean. Specifies the initial value for type=""checkbox"" and type=""radio"" inputs. defaultValue: A string. Specifies the initial value for a text input. These <input> props are relevant both for uncontrolled and controlled inputs: accept: A string. Specifies which filetypes are accepted by a type=""file"" input. alt: A string. Specifies the alternative image text for a type=""image"" input. capture: A string. Specifies the media (microphone, video, or camera) captured by a type=""file"" input. autoComplete: A string. Specifies one of the possible autocomplete behaviors. autoFocus: A boolean. If true, React will focus the element on mount. dirname: A string. Specifies the form field name for the element’s directionality. disabled: A boolean. If true, the input will not be interactive and will appear dimmed. children: <input> does not accept children. form: A string. Specifies the id of the <form> this input belongs to. If omitted, it’s the closest parent form. formAction: A string. Overrides the parent <form action> for type=""submit"" and type=""image"". formEnctype: A string. Overrides the parent <form enctype> for type=""submit"" and type=""image"". formMethod: A string. Overrides the parent <form method> for type=""submit"" and type=""image"". formNoValidate: A string. Overrides the parent <form noValidate> for type=""submit"" and type=""image"". formTarget: A string. Overrides the parent <form target> for type=""submit"" and type=""image"". height: A string. Specifies the image height for type=""image"". list: A string. Specifies the id of the <datalist> with the autocomplete options. max: A number. Specifies the maximum value of numerical and datetime inputs. maxLength: A number. Specifies the maximum length of text and other inputs. min: A number. Specifies the minimum value of numerical and datetime inputs. minLength: A number. Specifies the minimum length of text and other inputs. multiple: A boolean. Specifies whether multiple values are allowed for <type=""file"" and type=""email"". name: A string. Specifies the name for this input that’s submitted with the form. onChange: An Event handler function. Required for controlled inputs. Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside the <input> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. pattern: A string. Specifies the pattern that the value must match. placeholder: A string. Displayed in a dimmed color when the input value is empty. readOnly: A boolean. If true, the input is not editable by the user. required: A boolean. If true, the value must be provided for the form to submit. size: A number. Similar to setting width, but the unit depends on the control. src: A string. Specifies the image source for a type=""image"" input. step: A positive number or an 'any' string. Specifies the distance between valid values. type: A string. One of the input types. width: A string. Specifies the image width for a type=""image"" input. Checkboxes need checked (or defaultChecked), not value (or defaultValue). If a text input receives a string value prop, it will be treated as controlled. If a checkbox or a radio button receives a boolean checked prop, it will be treated as controlled. An input can’t be both controlled and uncontrolled at the same time. An input cannot switch between being controlled or uncontrolled over its lifetime. Every controlled input needs an onChange event handler that synchronously updates its backing value."
"Usage:  To display an input, render an <input> component. By default, it will be a text input. You can pass type=""checkbox"" for a checkbox, type=""radio"" for a radio button, or one of the other input types."
"Troubleshooting:  If you render an input with value but no onChange, you will see an error in the console:

##Code##
// 🔴 Bug: controlled text input with no onChange handler<input value={something} />
##Code##
 As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:

##Code##
// ✅ Good: uncontrolled input with an initial value<input defaultValue={something} />
##Code##
 If you want to control this input with a state variable, specify an onChange handler:

##Code##
// ✅ Good: controlled input with onChange<input value={something} onChange={e => setSomething(e.target.value)} />
##Code##
 If the value is intentionally read-only, add a readOnly prop to suppress the error:

##Code##
// ✅ Good: readonly controlled input without on change<input value={something} readOnly={true} />
##Code##
 If you render a checkbox with checked but no onChange, you will see an error in the console:

##Code##
// 🔴 Bug: controlled checkbox with no onChange handler<input type=""checkbox"" checked={something} />
##Code##
 As the error message suggests, if you only wanted to specify the initial value, pass defaultChecked instead:

##Code##
// ✅ Good: uncontrolled checkbox with an initial value<input type=""checkbox"" defaultChecked={something} />
##Code##
 If you want to control this checkbox with a state variable, specify an onChange handler:

##Code##
// ✅ Good: controlled checkbox with onChange<input type=""checkbox"" checked={something} onChange={e => setSomething(e.target.checked)} />
##Code##
 If the checkbox is intentionally read-only, add a readOnly prop to suppress the error:

##Code##
// ✅ Good: readonly controlled input without on change<input type=""checkbox"" checked={something} readOnly={true} />
##Code##
 If you control an input, you must update its state variable to the input’s value from the DOM during onChange. You can’t update it to something other than e.target.value (or e.target.checked for checkboxes):

##Code##
function handleChange(e) {  // 🔴 Bug: updating an input to something other than e.target.value  setFirstName(e.target.value.toUpperCase());}
##Code##
 You also can’t update it asynchronously:

##Code##
function handleChange(e) {  // 🔴 Bug: updating an input asynchronously  setTimeout(() => {    setFirstName(e.target.value);  }, 100);}
##Code##
 To fix your code, update it synchronously to e.target.value:

##Code##
function handleChange(e) {  // ✅ Updating a controlled input to e.target.value synchronously  setFirstName(e.target.value);}
##Code##
 If this doesn’t fix the problem, it’s possible that the input gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render, for example if the input or one of its parents always receives a different key attribute, or if you nest component function definitions (which is not supported and causes the “inner” component to always be considered a different tree). If you provide a value to the component, it must remain a string throughout its lifetime. You cannot pass value={undefined} first and later pass value=""some string"" because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined. If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string. Similarly, if you pass checked to a checkbox, ensure it’s always a boolean."
"Reference:  The built-in browser <option> component lets you render an option inside a <select> box.

##Code##
<select>  <option value=""someOption"">Some option</option>  <option value=""otherOption"">Other option</option></select>
##Code##
 See more examples below. <option> supports all common element props. Additionally, <option> supports these props: disabled: A boolean. If true, the option will not be selectable and will appear dimmed. label: A string. Specifies the meaning of the option. If not specified, the text inside the option is used. value: The value to be used when submitting the parent <select> in a form if this option is selected. React does not support the selected attribute on <option>. Instead, pass this option’s value to the parent <select defaultValue> for an uncontrolled select box, or <select value> for a controlled select."
Usage:  Render a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form. Read more about displaying a <select> with a list of <option> components.
"Reference:  To display a progress indicator, render the built-in browser <progress> component.

##Code##
<progress value={0.5} />
##Code##
 See more examples below. <progress> supports all common element props. Additionally, <progress> supports these props: max: A number. Specifies the maximum value. Defaults to 1. value: A number between 0 and max, or null for indeterminate progress. Specifies how much was done."
"Usage:  To display a progress indicator, render a <progress> component. You can pass a number value between 0 and the max value you specify. If you don’t pass a max value, it will assumed to be 1 by default. If the operation is not ongoing, pass value={null} to put the progress indicator into an indeterminate state."
"Reference:  To display a select box, render the built-in browser <select> component.

##Code##
<select>  <option value=""someOption"">Some option</option>  <option value=""otherOption"">Other option</option></select>
##Code##
 See more examples below. <select> supports all common element props. You can make a select box controlled by passing a value prop: value: A string (or an array of strings for multiple={true}). Controls which option is selected. Every value string match the value of some <option> nested inside the <select>. When you pass value, you must also pass an onChange handler that updates the passed value. If your <select> is uncontrolled, you may pass the defaultValue prop instead: defaultValue: A string (or an array of strings for multiple={true}). Specifies the initially selected option. These <select> props are relevant both for uncontrolled and controlled select boxes: autoComplete: A string. Specifies one of the possible autocomplete behaviors. autoFocus: A boolean. If true, React will focus the element on mount. children: <select> accepts <option>, <optgroup>, and <datalist> components as children. You can also pass your own components as long as they eventually render one of the allowed components. If you pass your own components that eventually render <option> tags, each <option> you render must have a value. disabled: A boolean. If true, the select box will not be interactive and will appear dimmed. form: A string. Specifies the id of the <form> this select box belongs to. If omitted, it’s the closest parent form. multiple: A boolean. If true, the browser allows multiple selection. name: A string. Specifies the name for this select box that’s submitted with the form. onChange: An Event handler function. Required for controlled select boxes. Fires immediately when the user picks a different option. Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. required: A boolean. If true, the value must be provided for the form to submit. size: A number. For multiple={true} selects, specifies the preferred number of initially visible items. Unlike in HTML, passing a selected attribute to <option> is not supported. Instead, use <select defaultValue> for uncontrolled select boxes and <select value> for controlled select boxes. If a select box receives a value prop, it will be treated as controlled. A select box can’t be both controlled and uncontrolled at the same time. A select box cannot switch between being controlled or uncontrolled over its lifetime. Every controlled select box needs an onChange event handler that synchronously updates its backing value."
Usage:  Render a <select> with a list of <option> components inside to display a select box. Give each <option> a value representing the data to be submitted with the form.
"Reference:  To display a text area, render the built-in browser <textarea> component.

##Code##
<textarea name=""postContent"" />
##Code##
 See more examples below. <textarea> supports all common element props. You can make a text area controlled by passing a value prop: value: A string. Controls the text inside the text area. When you pass value, you must also pass an onChange handler that updates the passed value. If your <textarea> is uncontrolled, you may pass the defaultValue prop instead: defaultValue: A string. Specifies the initial value for a text area. These <textarea> props are relevant both for uncontrolled and controlled text areas: autoComplete: Either 'on' or 'off'. Specifies the autocomplete behavior. autoFocus: A boolean. If true, React will focus the element on mount. children: <textarea> does not accept children. To set the initial value, use defaultValue. cols: A number. Specifies the default width in average character widths. Defaults to 20. disabled: A boolean. If true, the input will not be interactive and will appear dimmed. form: A string. Specifies the id of the <form> this input belongs to. If omitted, it’s the closest parent form. maxLength: A number. Specifies the maximum length of text. minLength: A number. Specifies the minimum length of text. name: A string. Specifies the name for this input that’s submitted with the form. onChange: An Event handler function. Required for controlled text areas. Fires immediately when the input’s value is changed by the user (for example, it fires on every keystroke). Behaves like the browser input event. onChangeCapture: A version of onChange that fires in the capture phase. onInput: An Event handler function. Fires immediately when the value is changed by the user. For historical reasons, in React it is idiomatic to use onChange instead which works similarly. onInputCapture: A version of onInput that fires in the capture phase. onInvalid: An Event handler function. Fires if an input fails validation on form submit. Unlike the built-in invalid event, the React onInvalid event bubbles. onInvalidCapture: A version of onInvalid that fires in the capture phase. onSelect: An Event handler function. Fires after the selection inside the <textarea> changes. React extends the onSelect event to also fire for empty selection and on edits (which may affect the selection). onSelectCapture: A version of onSelect that fires in the capture phase. placeholder: A string. Displayed in a dimmed color when the text area value is empty. readOnly: A boolean. If true, the text area is not editable by the user. required: A boolean. If true, the value must be provided for the form to submit. rows: A number. Specifies the default height in average character heights. Defaults to 2. wrap: Either 'hard', 'soft', or 'off'. Specifies how the text should be wrapped when submitting a form. Passing children like <textarea>something</textarea> is not allowed. Use defaultValue for initial content. If a text area receives a string value prop, it will be treated as controlled. A text area can’t be both controlled and uncontrolled at the same time. A text area cannot switch between being controlled or uncontrolled over its lifetime. Every controlled text area needs an onChange event handler that synchronously updates its backing value."
"Usage:  Render <textarea> to display a text area. You can specify its default size with the rows and cols attributes, but by default the user will be able to resize it. To disable resizing, you can specify resize: none in the CSS."
"Troubleshooting:  If you render a text area with value but no onChange, you will see an error in the console:

##Code##
// 🔴 Bug: controlled text area with no onChange handler<textarea value={something} />
##Code##
 As the error message suggests, if you only wanted to specify the initial value, pass defaultValue instead:

##Code##
// ✅ Good: uncontrolled text area with an initial value<textarea defaultValue={something} />
##Code##
 If you want to control this text area with a state variable, specify an onChange handler:

##Code##
// ✅ Good: controlled text area with onChange<textarea value={something} onChange={e => setSomething(e.target.value)} />
##Code##
 If the value is intentionally read-only, add a readOnly prop to suppress the error:

##Code##
// ✅ Good: readonly controlled text area without on change<textarea value={something} readOnly={true} />
##Code##
 If you control a text area, you must update its state variable to the text area’s value from the DOM during onChange. You can’t update it to something other than e.target.value:

##Code##
function handleChange(e) {  // 🔴 Bug: updating an input to something other than e.target.value  setFirstName(e.target.value.toUpperCase());}
##Code##
 You also can’t update it asynchronously:

##Code##
function handleChange(e) {  // 🔴 Bug: updating an input asynchronously  setTimeout(() => {    setFirstName(e.target.value);  }, 100);}
##Code##
 To fix your code, update it synchronously to e.target.value:

##Code##
function handleChange(e) {  // ✅ Updating a controlled input to e.target.value synchronously  setFirstName(e.target.value);}
##Code##
 If this doesn’t fix the problem, it’s possible that the text area gets removed and re-added from the DOM on every keystroke. This can happen if you’re accidentally resetting state on every re-render. For example, this can happen if the text area or one of its parents always receives a different key attribute, or if you nest component definitions (which is not allowed in React and causes the “inner” component to remount on every render). If you provide a value to the component, it must remain a string throughout its lifetime. You cannot pass value={undefined} first and later pass value=""some string"" because React won’t know whether you want the component to be uncontrolled or controlled. A controlled component should always receive a string value, not null or undefined. If your value is coming from an API or a state variable, it might be initialized to null or undefined. In that case, either set it to an empty string ('') initially, or pass value={someValue ?? ''} to ensure value is a string."
"Reference:  To link to external resources such as stylesheets, fonts, and icons, or to annotate the document with link metadata, render the built-in browser <link> component. You can render <link> from any component and React will in most cases place the corresponding DOM element in the document head.

##Code##
<link rel=""icon"" href=""favicon.ico"" />
##Code##
 See more examples below. <link> supports all common element props. rel: a string, required. Specifies the relationship to the resource. React treats links with rel=""stylesheet"" differently from other links. These props apply when rel=""stylesheet"": precedence: a string. Tells React where to rank the <link> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. Its value can be (in order of precedence) ""reset"", ""low"", ""medium"", ""high"". Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using the preload or preinit functions. media: a string. Restricts the spreadsheet to a certain media query. title: a string. Specifies the name of an alternative stylesheet. These props apply when rel=""stylesheet"" but disable React’s special treatment of stylesheets: disabled: a boolean. Disables the spreadsheet. onError: a function. Called when the stylesheet fails to load. onLoad: a function. Called when the stylesheet finishes being loaded. These props apply when rel=""preload"" or rel=""modulepreload"": as: a string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker. imageSrcSet: a string. Applicable only when as=""image"". Specifies the source set of the image. imageSizes: a string. Applicable only when as=""image"". Specifies the sizes of the image. These props apply when rel=""icon"" or rel=""apple-touch-icon"": sizes: a string. The sizes of the icon. These props apply in all cases: href: a string. The URL of the linked resource. crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to ""fetch"". referrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url. fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low. hrefLang: a string. The language of the linked resource. integrity: a string. A cryptographic hash of the resource, to verify its authenticity. type: a string. The MIME type of the linked resource. Props that are not recommended for use with React: blocking: a string. If set to ""render"", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense. React will always place the DOM element corresponding to the <link> component within the document’s <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <link> to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render <link> components itself. There are a few exceptions to this: If the <link> has a rel=""stylesheet"" prop, then it has to also have a precedence prop to get this special behavior. This is because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop. If the precedence prop is omitted, there is no special behavior. If the <link> has an itemProp prop, there is no special behavior, because in this case it doesn’t apply to the document but instead represents metadata about a specific part of the page. If the <link> has an onLoad or onError prop, because in that case you are managing the loading of the linked resource manually within your React component. In addition, if the <link> is to a stylesheet (namely, it has rel=""stylesheet"" in its props), React treats it specially in the following ways: The component that renders <link> will suspend while the stylesheet is loading. If multiple components render links to the same stylesheet, React will de-duplicate them and only put a single link into the DOM. Two links are considered the same if they have the same href prop. There are two exception to this special behavior: If the link doesn’t have a precedence prop, there is no special behavior, because the order of stylesheets within the document is significant, so React needs to know how to order this stylesheet relative to others, which you specify using the precedence prop. If you supply any of the onLoad, onError, or disabled props, there is no special behavior, because these props indicate that you are managing the loading of the stylesheet manually within your component. This special treatment comes with two caveats: React will ignore changes to props after the link has been rendered. (React will issue a warning in development if this happens.) React may leave the link in the DOM even after the component that rendered it has been unmounted."
"Usage:  You can annotate the document with links to related resources such as an icon, canonical URL, or pingback. React will place this metadata within the document <head> regardless of where in the React tree it is rendered. If a component depends on a certain stylesheet in order to be displayed correctly, you can render a link to that stylesheet within the component. Your component will suspend while the stylesheet is loading. You must supply the precedence prop, which tells React where to place this stylesheet relative to others — stylesheets with higher precedence can override those with lower precedence. Stylesheets can conflict with each other, and when they do, the browser goes with the one that comes later in the document. React lets you control the order of stylesheets with the precedence prop. In this example, two components render stylesheets, and the one with the higher precedence goes later in the document even though the component that renders it comes earlier. If you render the same stylesheet from multiple components, React will place only a single <link> in the document head. You can use the <link> component with the itemProp prop to annotate specific items within the document with links to related resources. In this case, React will not place these annotations within the document <head> but will place them like any other React component.

##Code##
<section itemScope>  <h3>Annotating specific items</h3>  <link itemProp=""author"" href=""http://example.com/"" />  <p>...</p></section>
##Code##"
"Reference:  To add document metadata, render the built-in browser <meta> component. You can render <meta> from any component and React will always place the corresponding DOM element in the document head.

##Code##
<meta name=""keywords"" content=""React, JavaScript, semantic markup, html"" />
##Code##
 See more examples below. <meta> supports all common element props. It should have exactly one of the following props: name, httpEquiv, charset, itemProp. The <meta> component does something different depending on which of these props is specified. name: a string. Specifies the kind of metadata to be attached to the document. charset: a string. Specifies the character set used by the document. The only valid value is ""utf-8"". httpEquiv: a string. Specifies a directive for processing the document. itemProp: a string. Specifies metadata about a particular item within the document rather than the document as a whole. content: a string. Specifies the metadata to be attached when used with the name or itemProp props or the behavior of the directive when used with the httpEquiv prop. React will always place the DOM element corresponding to the <meta> component within the document’s <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <meta> to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render <meta> components itself. There is one exception to this: if <meta> has an itemProp prop, there is no special behavior, because in this case it doesn’t represent metadata about the document but rather metadata about a specific part of the page."
"Usage:  You can annotate the document with metadata such as keywords, a summary, or the author’s name. React will place this metadata within the document <head> regardless of where in the React tree it is rendered.

##Code##
<meta name=""author"" content=""John Smith"" /><meta name=""keywords"" content=""React, JavaScript, semantic markup, html"" /><meta name=""description"" content=""API reference for the <meta> component in React DOM"" />
##Code##
 You can render the <meta> component from any component. React will put a <meta> DOM node in the document <head>. You can use the <meta> component with the itemProp prop to annotate specific items within the document with metadata. In this case, React will not place these annotations within the document <head> but will place them like any other React component.

##Code##
<section itemScope>  <h3>Annotating specific items</h3>  <meta itemProp=""description"" content=""API reference for using <meta> with itemProp"" />  <p>...</p></section>
##Code##"
"Reference:  To add inline or external scripts to your document, render the built-in browser <script> component. You can render <script> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical scripts.

##Code##
<script> alert(""hi!"") </script><script src=""script.js"" />
##Code##
 See more examples below. <script> supports all common element props. It should have either children or a src prop. children: a string. The source code of an inline script. src: a string. The URL of an external script. Other supported props: async: a boolean. Allows the browser to defer execution of the script until the rest of the document has been processed — the preferred behavior for performance. crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. fetchPriority: a string. Lets the browser rank scripts in priority when fetching multiple scripts at the same time. Can be ""high"", ""low"", or ""auto"" (the default). integrity: a string. A cryptographic hash of the script, to verify its authenticity. noModule: a boolean. Disables the script in browsers that support ES modules — allowing for a fallback script for browsers that do not. nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy. referrer: a string. Says what Referer header to send when fetching the script and any resources that the script fetches in turn. type: a string. Says whether the script is a classic script, ES module, or import map. Props that disable React’s special treatment of scripts: onError: a function. Called when the script fails to load. onLoad: a function. Called when the script finishes being loaded. Props that are not recommended for use with React: blocking: a string. If set to ""render"", instructs the browser not to render the page until the scriptsheet is loaded. React provides more fine-grained control using Suspense. defer: a string. Prevents the browser from executing the script until the document is done loading. Not compatible with streaming server-rendered components. Use the async prop instead. React can move <script> components to the document’s <head>, de-duplicate identical scripts, and suspend while the script is loading. To opt into this behavior, provide the src and async={true} props. React will de-duplicate scripts if they have the same src. The async prop must be true to allow scripts to be safely moved. If you supply any of the onLoad or onError props, there is no special behavior, because these props indicate that you are managing the loading of the script manually within your component. This special treatment comes with two caveats: React will ignore changes to props after the script has been rendered. (React will issue a warning in development if this happens.) React may leave the script in the DOM even after the component that rendered it has been unmounted. (This has no effect as scripts just execute once when they are inserted into the DOM.)"
"Usage:  If a component depends on certain scripts in order to be displayed correctly, you can render a <script> within the component. If you supply an src and async prop, your component will suspend while the script is loading. React will de-duplicate scripts that have the same src, inserting only one of them into the DOM even if multiple components render it. To include an inline script, render the <script> component with the script source code as its children. Inline scripts are not de-duplicated or moved to the document <head>, and since they don’t load any external resources, they will not cause your component to suspend."
"Reference:  To add inline styles to your document, render the built-in browser <style> component. You can render <style> from any component and React will in certain cases place the corresponding DOM element in the document head and de-duplicate identical styles.

##Code##
<style>{` p { color: red; } `}</style>
##Code##
 See more examples below. <style> supports all common element props. children: a string, required. The contents of the stylesheet. precedence: a string. Tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. Its value can be (in order of precedence) ""reset"", ""low"", ""medium"", ""high"". Stylesheets with the same precedence go together whether they are <link> or inline <style> tags or loaded using the preload or preinit functions. href: a string. Allows React to de-duplicate styles that have the same href. media: a string. Restricts the spreadsheet to a certain media query. nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy. title: a string. Specifies the name of an alternative stylesheet. Props that are not recommended for use with React: blocking: a string. If set to ""render"", instructs the browser not to render the page until the stylesheet is loaded. React provides more fine-grained control using Suspense. React can move <style> components to the document’s <head>, de-duplicate identical stylesheets, and suspend while the stylesheet is loading. To opt into this behavior, provide the href and precedence props. React will de-duplicate styles if they have the same href. The precedence prop tells React where to rank the <style> DOM node relative to others in the document <head>, which determines which stylesheet can override the other. This special treatment comes with two caveats: React will ignore changes to props after the style has been rendered. (React will issue a warning in development if this happens.) React may leave the style in the DOM even after the component that rendered it has been unmounted."
"Usage:  If a component depends on certain CSS styles in order to be displayed correctly, you can render an inline stylesheet within the component. If you supply an href and precedence prop, your component will suspend while the stylesheet is loading. (Even with inline stylesheets, there may be a loading time due to fonts and images that the stylesheet refers to.) The href prop should uniquely identify the stylesheet, because React will de-duplicate stylesheets that have the same href."
"Reference:  To specify the title of the document, render the built-in browser <title> component. You can render <title> from any component and React will always place the corresponding DOM element in the document head.

##Code##
<title>My Blog</title>
##Code##
 See more examples below. <title> supports all common element props. children: <title> accepts only text as a child. This text will become the title of the document. You can also pass your own components as long as they only render text. React will always place the DOM element corresponding to the <title> component within the document’s <head>, regardless of where in the React tree it is rendered. The <head> is the only valid place for <title> to exist within the DOM, yet it’s convenient and keeps things composable if a component representing a specific page can render its <title> itself. There are two exception to this: If <title> is within an <svg> component, then there is no special behavior, because in this context it doesn’t represent the document’s title but rather is an accessibility annotation for that SVG graphic. If the <title> has an itemProp prop, there is no special behavior, because in this case it doesn’t represent the document’s title but rather metadata about a specific part of the page."
"Usage:  Render the <title> component from any component with text as its children. React will put a <title> DOM node in the document <head>. The children of the <title> component must be a single string of text. (Or a single number or a single object with a toString method.) It might not be obvious, but using JSX curly braces like this:

##Code##
<title>Results page {pageNumber}</title> // 🔴 Problem: This is not a single string
##Code##
 … actually causes the <title> component to get a two-element array as its children (the string ""Results page"" and the value of pageNumber). This will cause an error. Instead, use string interpolation to pass <title> a single string:

##Code##
<title>{`Results page ${pageNumber}`}</title>
##Code##"
APIs:  These APIs can be imported from your components. They are rarely used: createPortal lets you render child components in a different part of the DOM tree. flushSync lets you force React to flush a state update and update the DOM synchronously.
"Resource Preloading APIs:  These APIs can be used to make apps faster by pre-loading resources such as scripts, stylesheets, and fonts as soon as you know you need them, for example before navigating to another page where the resources will be used. React-based frameworks frequently handle resource loading for you, so you might not have to call these APIs yourself. Consult your framework’s documentation for details. prefetchDNS lets you prefetch the IP address of a DNS domain name that you expect to connect to. preconnect lets you connect to a server you expect to request resources from, even if you don’t know what resources you’ll need yet. preload lets you fetch a stylesheet, font, image, or external script that you expect to use. preloadModule lets you fetch an ESM module that you expect to use. preinit lets you fetch and evaluate an external script or fetch and insert a stylesheet. preinitModule lets you fetch and evaluate an ESM module."
Entry points:  The react-dom package provides two additional entry points: react-dom/client contains APIs to render React components on the client (in the browser). react-dom/server contains APIs to render React components on the server.
Deprecated APIs:  findDOMNode finds the closest DOM node corresponding to a class component instance. hydrate mounts a tree into the DOM created from server HTML. Deprecated in favor of hydrateRoot. render mounts a tree into the DOM. Deprecated in favor of createRoot. unmountComponentAtNode unmounts a tree from the DOM. Deprecated in favor of root.unmount().
"Reference:  To create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered:

##Code##
import { createPortal } from 'react-dom';// ...<div>  <p>This child is placed in the parent div.</p>  {createPortal(    <p>This child is placed in the document body.</p>,    document.body  )}</div>
##Code##
 See more examples below. A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the React component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the React tree. children: Anything that can be rendered with React, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these. domNode: Some DOM node, such as those returned by document.getElementById(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated. optional key: A unique string or number to be used as the portal’s key. createPortal returns a React node that can be included into JSX or returned from a React component. If React encounters it in the render output, it will place the provided children inside the provided domNode. Events from portals propagate according to the React tree rather than the DOM tree. For example, if you click inside a portal, and the portal is wrapped in <div onClick>, that onClick handler will fire. If this causes issues, either stop the event propagation from inside the portal, or move the portal itself up in the React tree."
"Usage:  Portals let your components render some of their children into a different place in the DOM. This lets a part of your component “escape” from whatever containers it may be in. For example, a component can display a modal dialog or a tooltip that appears above and outside of the rest of the page. To create a portal, render the result of createPortal with some JSX and the DOM node where it should go:

##Code##
import { createPortal } from 'react-dom';function MyComponent() {  return (    <div style={{ border: '2px solid black' }}>      <p>This child is placed in the parent div.</p>      {createPortal(        <p>This child is placed in the document body.</p>,        document.body      )}    </div>  );}
##Code##
 React will put the DOM nodes for the JSX you passed inside of the DOM node you provided. Without a portal, the second <p> would be placed inside the parent <div>, but the portal “teleported” it into the document.body:"
"Reference:  Call flushSync to force React to flush any pending work and update the DOM synchronously.

##Code##
import { flushSync } from 'react-dom';flushSync(() => {  setSomething(123);});
##Code##
 Most of the time, flushSync can be avoided. Use flushSync as last resort. See more examples below. callback: A function. React will immediately call this callback and flush any updates it contains synchronously. It may also flush any pending updates, or Effects, or updates inside of Effects. If an update suspends as a result of this flushSync call, the fallbacks may be re-shown. flushSync returns undefined. flushSync can significantly hurt performance. Use sparingly. flushSync may force pending Suspense boundaries to show their fallback state. flushSync may run pending Effects and synchronously apply any updates they contain before returning. flushSync may flush updates outside the callback when necessary to flush the updates inside the callback. For example, if there are pending updates from a click, React may flush those before flushing the updates inside the callback."
"Usage:  When integrating with third-party code such as browser APIs or UI libraries, it may be necessary to force React to flush updates. Use flushSync to force React to flush any state updates inside the callback synchronously:

##Code##
flushSync(() => {  setSomething(123);});// By this line, the DOM is updated.
##Code##
 This ensures that, by the time the next line of code runs, React has already updated the DOM. Using flushSync is uncommon, and using it often can significantly hurt the performance of your app. If your app only uses React APIs, and does not integrate with third-party libraries, flushSync should be unnecessary. However, it can be helpful for integrating with third-party code like browser APIs. Some browser APIs expect results inside of callbacks to be written to the DOM synchronously, by the end of the callback, so the browser can do something with the rendered DOM. In most cases, React handles this for you automatically. But in some cases it may be necessary to force a synchronous update. For example, the browser onbeforeprint API allows you to change the page immediately before the print dialog opens. This is useful for applying custom print styles that allow the document to display better for printing. In the example below, you use flushSync inside of the onbeforeprint callback to immediately “flush” the React state to the DOM. Then, by the time the print dialog opens, isPrinting displays “yes”:"
"Reference:  Call findDOMNode to find the browser DOM node for a given React class component instance.

##Code##
import { findDOMNode } from 'react-dom';const domNode = findDOMNode(componentInstance);
##Code##
 See more examples below. componentInstance: An instance of the Component subclass. For example, this inside a class component. findDOMNode returns the first closest browser DOM node within the given componentInstance. When a component renders to null, or renders false, findDOMNode returns null. When a component renders to a string, findDOMNode returns a text DOM node containing that value. A component may return an array or a Fragment with multiple children. In that case findDOMNode, will return the DOM node corresponding to the first non-empty child. findDOMNode only works on mounted components (that is, components that have been placed in the DOM). If you try to call this on a component that has not been mounted yet (like calling findDOMNode() in render() on a component that has yet to be created), an exception will be thrown. findDOMNode only returns the result at the time of your call. If a child component renders a different node later, there is no way for you to be notified of this change. findDOMNode accepts a class component instance, so it can’t be used with function components."
"Usage:  Call findDOMNode with a class component instance (usually, this) to find the DOM node it has rendered.

##Code##
class AutoselectingInput extends Component {  componentDidMount() {    const input = findDOMNode(this);    input.select()  }  render() {    return <input defaultValue=""Hello"" />  }}
##Code##
 Here, the input variable will be set to the <input> DOM element. This lets you do something with it. For example, when clicking “Show example” below mounts the input, input.select() selects all text in the input:"
"Alternatives:  Code using findDOMNode is fragile because the connection between the JSX node and the code manipulating the corresponding DOM node is not explicit. For example, try wrapping this <input /> into a <div>:"
"Reference:  Call hydrate in React 17 and below to “attach” React to existing HTML that was already rendered by React in a server environment.

##Code##
import { hydrate } from 'react-dom';hydrate(reactNode, domNode);
##Code##
 React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrate call with its root component. See more examples below. reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToString(<App />) in React 17. domNode: A DOM element that was rendered as the root element on the server. optional: callback: A function. If passed, React will call it after your component is hydrated. hydrate returns null. hydrate expects the rendered content to be identical with the server-rendered content. React can patch up differences in text content, but you should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive. You’ll likely have only one hydrate call in your app. If you use a framework, it might do this call for you. If your app is client-rendered with no HTML rendered already, using hydrate() is not supported. Use render() (for React 17 and below) or createRoot() (for React 18+) instead."
"Usage:  Call hydrate to attach a React component into a server-rendered browser DOM node.

##Code##
import { hydrate } from 'react-dom';hydrate(<App />, document.getElementById('root'));
##Code##
 Using hydrate() to render a client-only app (an app without server-rendered HTML) is not supported. Use render() (in React 17 and below) or createRoot() (in React 18+) instead. In React, “hydration” is how React “attaches” to existing HTML that was already rendered by React in a server environment. During hydration, React will attempt to attach event listeners to the existing markup and take over rendering the app on the client. In apps fully built with React, you will usually only hydrate one “root”, once at startup for your entire app."
"Reference:  To preconnect to a host, call the preconnect function from react-dom.

##Code##
import { preconnect } from 'react-dom';function AppRoot() {  preconnect(""https://example.com"");  // ...}
##Code##
 See more examples below. The preconnect function provides the browser with a hint that it should open a connection to the given server. If the browser chooses to do so, this can speed up the loading of resources from that server. href: a string. The URL of the server you want to connect to. preconnect returns nothing. Multiple calls to preconnect with the same server have the same effect as a single call. In the browser, you can call preconnect in any situation: while rendering a component, in an Effect, in an event handler, and so on. In server-side rendering or when rendering Server Components, preconnect only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored. If you know the specific resources you’ll need, you can call other functions instead that will start loading the resources right away. There is no benefit to preconnecting to the same server the webpage itself is hosted from because it’s already been connected to by the time the hint would be given."
"Usage:  Call preconnect when rendering a component if you know that its children will load external resources from that host.

##Code##
import { preconnect } from 'react-dom';function AppRoot() {  preconnect(""https://example.com"");  return ...;}
##Code##
 Call preconnect in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

##Code##
import { preconnect } from 'react-dom';function CallToAction() {  const onClick = () => {    preconnect('http://example.com');    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
##Code##"
"Reference:  To look up a host, call the prefetchDNS function from react-dom.

##Code##
import { prefetchDNS } from 'react-dom';function AppRoot() {  prefetchDNS(""https://example.com"");  // ...}
##Code##
 See more examples below. The prefetchDNS function provides the browser with a hint that it should look up the IP address of a given server. If the browser chooses to do so, this can speed up the loading of resources from that server. href: a string. The URL of the server you want to connect to. prefetchDNS returns nothing. Multiple calls to prefetchDNS with the same server have the same effect as a single call. In the browser, you can call prefetchDNS in any situation: while rendering a component, in an Effect, in an event handler, and so on. In server-side rendering or when rendering Server Components, prefetchDNS only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored. If you know the specific resources you’ll need, you can call other functions instead that will start loading the resources right away. There is no benefit to prefetching the same server the webpage itself is hosted from because it’s already been looked up by the time the hint would be given. Compared with preconnect, prefetchDNS may be better if you are speculatively connecting to a large number of domains, in which case the overhead of preconnections might outweigh the benefit."
"Usage:  Call prefetchDNS when rendering a component if you know that its children will load external resources from that host.

##Code##
import { prefetchDNS } from 'react-dom';function AppRoot() {  prefetchDNS(""https://example.com"");  return ...;}
##Code##
 Call prefetchDNS in an event handler before transitioning to a page or state where external resources will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

##Code##
import { prefetchDNS } from 'react-dom';function CallToAction() {  const onClick = () => {    prefetchDNS('http://example.com');    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
##Code##"
"Reference:  To preinit a script or stylesheet, call the preinit function from react-dom.

##Code##
import { preinit } from 'react-dom';function AppRoot() {  preinit(""https://example.com/script.js"", {as: ""script""});  // ...}
##Code##
 See more examples below. The preinit function provides the browser with a hint that it should start downloading and executing the given resource, which can save time. Scripts that you preinit are executed when they finish downloading. Stylesheets that you preinit are inserted into the document, which causes them to go into effect right away. href: a string. The URL of the resource you want to download and execute. options: an object. It contains the following properties: as: a required string. The type of resource. Its possible values are script and style. precedence: a string. Required with stylesheets. Says where to insert the stylesheet relative to others. Stylesheets with higher precedence can override those with lower precedence. The possible values are reset, low, medium, high. crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to ""fetch"". integrity: a string. A cryptographic hash of the resource, to verify its authenticity. nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy. fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low. preinit returns nothing. Multiple calls to preinit with the same href have the same effect as a single call. In the browser, you can call preinit in any situation: while rendering a component, in an Effect, in an event handler, and so on. In server-side rendering or when rendering Server Components, preinit only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
"Usage:  Call preinit when rendering a component if you know that it or its children will use a specific resource, and you’re OK with the resource being evaluated and thereby taking effect immediately upon being downloaded."
"Reference:  To preinit an ESM module, call the preinitModule function from react-dom.

##Code##
import { preinitModule } from 'react-dom';function AppRoot() {  preinitModule(""https://example.com/module.js"", {as: ""script""});  // ...}
##Code##
 See more examples below. The preinitModule function provides the browser with a hint that it should start downloading and executing the given module, which can save time. Modules that you preinit are executed when they finish downloading. href: a string. The URL of the module you want to download and exeucute. options: an object. It contains the following properties: as: a required string. It must be 'script'. crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. integrity: a string. A cryptographic hash of the module, to verify its authenticity. nonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy. preinitModule returns nothing. Multiple calls to preinitModule with the same href have the same effect as a single call. In the browser, you can call preinitModule in any situation: while rendering a component, in an Effect, in an event handler, and so on. In server-side rendering or when rendering Server Components, preinitModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
"Usage:  Call preinitModule when rendering a component if you know that it or its children will use a specific module and you’re OK with the module being evaluated and thereby taking effect immediately upon being downloaded.

##Code##
import { preinitModule } from 'react-dom';function AppRoot() {  preinitModule(""https://example.com/module.js"", {as: ""script""});  return ...;}
##Code##
 If you want the browser to download the module but not to execute it right away, use preloadModule instead. If you want to preinit a script that isn’t an ESM module, use preinit. Call preinitModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

##Code##
import { preinitModule } from 'react-dom';function CallToAction() {  const onClick = () => {    preinitModule(""https://example.com/module.js"", {as: ""script""});    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
##Code##"
"Reference:  To preload a resource, call the preload function from react-dom.

##Code##
import { preload } from 'react-dom';function AppRoot() {  preload(""https://example.com/font.woff2"", {as: ""font""});  // ...}
##Code##
 See more examples below. The preload function provides the browser with a hint that it should start downloading the given resource, which can save time. href: a string. The URL of the resource you want to download. options: an object. It contains the following properties: as: a required string. The type of resource. Its possible values are audio, document, embed, fetch, font, image, object, script, style, track, video, worker. crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. It is required when as is set to ""fetch"". referrerPolicy: a string. The Referrer header to send when fetching. Its possible values are no-referrer-when-downgrade (the default), no-referrer, origin, origin-when-cross-origin, and unsafe-url. integrity: a string. A cryptographic hash of the resource, to verify its authenticity. type: a string. The MIME type of the resource. nonce: a string. A cryptographic nonce to allow the resource when using a strict Content Security Policy. fetchPriority: a string. Suggests a relative priority for fetching the resource. The possible values are auto (the default), high, and low. imageSrcSet: a string. For use only with as: ""image"". Specifies the source set of the image. imageSizes: a string. For use only with as: ""image"". Specifies the sizes of the image. preload returns nothing. Multiple equivalent calls to preload have the same effect as a single call. Calls to preload are considered equivalent according to the following rules: Two calls are equivalent if they have the same href, except: If as is set to image, two calls are equivalent if they have the same href, imageSrcSet, and imageSizes. In the browser, you can call preload in any situation: while rendering a component, in an Effect, in an event handler, and so on. In server-side rendering or when rendering Server Components, preload only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
Usage:  Call preload when rendering a component if you know that it or its children will use a specific resource.
"Reference:  To preload an ESM module, call the preloadModule function from react-dom.

##Code##
import { preloadModule } from 'react-dom';function AppRoot() {  preloadModule(""https://example.com/module.js"", {as: ""script""});  // ...}
##Code##
 See more examples below. The preloadModule function provides the browser with a hint that it should start downloading the given module, which can save time. href: a string. The URL of the module you want to download. options: an object. It contains the following properties: as: a required string. It must be 'script'. crossOrigin: a string. The CORS policy to use. Its possible values are anonymous and use-credentials. integrity: a string. A cryptographic hash of the module, to verify its authenticity. nonce: a string. A cryptographic nonce to allow the module when using a strict Content Security Policy. preloadModule returns nothing. Multiple calls to preloadModule with the same href have the same effect as a single call. In the browser, you can call preloadModule in any situation: while rendering a component, in an Effect, in an event handler, and so on. In server-side rendering or when rendering Server Components, preloadModule only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored."
"Usage:  Call preloadModule when rendering a component if you know that it or its children will use a specific module.

##Code##
import { preloadModule } from 'react-dom';function AppRoot() {  preloadModule(""https://example.com/module.js"", {as: ""script""});  return ...;}
##Code##
 If you want the browser to start executing the module immediately (rather than just downloading it), use preinitModule instead. If you want to load a script that isn’t an ESM module, use preload. Call preloadModule in an event handler before transitioning to a page or state where the module will be needed. This gets the process started earlier than if you call it during the rendering of the new page or state.

##Code##
import { preloadModule } from 'react-dom';function CallToAction() {  const onClick = () => {    preloadModule(""https://example.com/module.js"", {as: ""script""});    startWizard();  }  return (    <button onClick={onClick}>Start Wizard</button>  );}
##Code##"
"Reference:  Call render to display a React component inside a browser DOM element.

##Code##
import { render } from 'react-dom';const domNode = document.getElementById('root');render(<App />, domNode);
##Code##
 React will display <App /> in the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one render call with its root component. A page that uses “sprinkles” of React for parts of the page may have as many render calls as needed. See more examples below. reactNode: A React node that you want to display. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined. domNode: A DOM element. React will display the reactNode you pass inside this DOM element. From this moment, React will manage the DOM inside the domNode and update it when your React tree changes. optional callback: A function. If passed, React will call it after your component is placed into the DOM. render usually returns null. However, if the reactNode you pass is a class component, then it will return an instance of that component. In React 18, render was replaced by createRoot. Please use createRoot for React 18 and beyond. The first time you call render, React will clear all the existing HTML content inside the domNode before rendering the React component into it. If your domNode contains HTML generated by React on the server or during the build, use hydrate() instead, which attaches the event handlers to the existing HTML. If you call render on the same domNode more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by “matching it up” with the previously rendered tree. Calling render on the same domNode again is similar to calling the set function on the root component: React avoids unnecessary DOM updates. If your app is fully built with React, you’ll likely have only one render call in your app. (If you use a framework, it might do this call for you.) When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), use createPortal instead of render."
"Usage:  Call render to display a React component inside a browser DOM node.

##Code##
import { render } from 'react-dom';import App from './App.js';render(<App />, document.getElementById('root'));
##Code##
 In apps fully built with React, you will usually only do this once at startup—to render the “root” component."
"Reference:  Call unmountComponentAtNode to remove a mounted React component from the DOM and clean up its event handlers and state.

##Code##
import { unmountComponentAtNode } from 'react-dom';const domNode = document.getElementById('root');render(<App />, domNode);unmountComponentAtNode(domNode);
##Code##
 See more examples below. domNode: A DOM element. React will remove a mounted React component from this element. unmountComponentAtNode returns true if a component was unmounted and false otherwise."
"Usage:  Call unmountComponentAtNode to remove a mounted React component from a browser DOM node and clean up its event handlers and state.

##Code##
import { render, unmountComponentAtNode } from 'react-dom';import App from './App.js';const rootNode = document.getElementById('root');render(<App />, rootNode);// ...unmountComponentAtNode(rootNode);
##Code##
 Occasionally, you may want to “sprinkle” React on an existing page, or a page that is not fully written in React. In those cases, you may need to “stop” the React app, by removing all of the UI, state, and listeners from the DOM node it was rendered to. In this example, clicking “Render React App” will render a React app. Click “Unmount React App” to destroy it:"
Client APIs:  createRoot lets you create a root to display React components inside a browser DOM node. hydrateRoot lets you display React components inside a browser DOM node whose HTML content was previously generated by react-dom/server.
"Browser support:  React supports all popular browsers, including Internet Explorer 9 and above. Some polyfills are required for older browsers such as IE 9 and IE 10."
"Reference:  Call createRoot to create a React root for displaying content inside a browser DOM element.

##Code##
import { createRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = createRoot(domNode);
##Code##
 React will create a root for the domNode, and take over managing the DOM inside it. After you’ve created a root, you need to call root.render to display a React component inside of it:

##Code##
root.render(<App />);
##Code##
 An app fully built with React will usually only have one createRoot call for its root component. A page that uses “sprinkles” of React for parts of the page may have as many separate roots as needed. See more examples below. domNode: A DOM element. React will create a root for this DOM element and allow you to call functions on the root, such as render to display rendered React content. optional options: An object with options for this React root. optional onRecoverableError: Callback called when React automatically recovers from errors. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. createRoot returns an object with two methods: render and unmount. If your app is server-rendered, using createRoot() is not supported. Use hydrateRoot() instead. You’ll likely have only one createRoot call in your app. If you use a framework, it might do this call for you. When you want to render a piece of JSX in a different part of the DOM tree that isn’t a child of your component (for example, a modal or a tooltip), use createPortal instead of createRoot. Call root.render to display a piece of JSX (“React node”) into the React root’s browser DOM node.

##Code##
root.render(<App />);
##Code##
 React will display <App /> in the root, and take over managing the DOM inside it. See more examples below. reactNode: A React node that you want to display. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined. root.render returns undefined. The first time you call root.render, React will clear all the existing HTML content inside the React root before rendering the React component into it. If your root’s DOM node contains HTML generated by React on the server or during the build, use hydrateRoot() instead, which attaches the event handlers to the existing HTML. If you call render on the same root more than once, React will update the DOM as necessary to reflect the latest JSX you passed. React will decide which parts of the DOM can be reused and which need to be recreated by “matching it up” with the previously rendered tree. Calling render on the same root again is similar to calling the set function on the root component: React avoids unnecessary DOM updates. Call root.unmount to destroy a rendered tree inside a React root.

##Code##
root.unmount();
##Code##
 An app fully built with React will usually not have any calls to root.unmount. This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. In that case, you need to tell React to “stop” managing the removed root’s content by calling root.unmount. Otherwise, the components inside the removed root won’t know to clean up and free up global resources like subscriptions. Calling root.unmount will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree. root.unmount does not accept any parameters. root.unmount returns undefined. Calling root.unmount will unmount all the components in the tree and “detach” React from the root DOM node. Once you call root.unmount you cannot call root.render again on the same root. Attempting to call root.render on an unmounted root will throw a “Cannot update an unmounted root” error. However, you can create a new root for the same DOM node after the previous root for that node has been unmounted."
"Usage:  If your app is fully built with React, create a single root for your entire app.

##Code##
import { createRoot } from 'react-dom/client';const root = createRoot(document.getElementById('root'));root.render(<App />);
##Code##
 Usually, you only need to run this code once at startup. It will:"
"Troubleshooting:  Make sure you haven’t forgotten to actually render your app into the root:

##Code##
import { createRoot } from 'react-dom/client';import App from './App.js';const root = createRoot(document.getElementById('root'));root.render(<App />);
##Code##
 Until you do that, nothing is displayed. This error means that whatever you’re passing to createRoot is not a DOM node. If you’re not sure what’s happening, try logging it:

##Code##
const domNode = document.getElementById('root');console.log(domNode); // ???const root = createRoot(domNode);root.render(<App />);
##Code##
 For example, if domNode is null, it means that getElementById returned null. This will happen if there is no node in the document with the given ID at the time of your call. There may be a few reasons for it: Another common way to get this error is to write createRoot(<App />) instead of createRoot(domNode). This error means that whatever you’re passing to root.render is not a React component. This may happen if you call root.render with Component instead of <Component />:

##Code##
// 🚩 Wrong: App is a function, not a Component.root.render(App);// ✅ Correct: <App /> is a component.root.render(<App />);
##Code##
 Or if you pass a function to root.render, instead of the result of calling it:

##Code##
// 🚩 Wrong: createApp is a function, not a component.root.render(createApp);// ✅ Correct: call createApp to return a component.root.render(createApp());
##Code##
 If your app is server-rendered and includes the initial HTML generated by React, you might notice that creating a root and calling root.render deletes all that HTML, and then re-creates all the DOM nodes from scratch. This can be slower, resets focus and scroll positions, and may lose other user input. Server-rendered apps must use hydrateRoot instead of createRoot:

##Code##
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(  document.getElementById('root'),  <App />);
##Code##
 Note that its API is different. In particular, usually there will be no further root.render call."
"Reference:  Call hydrateRoot to “attach” React to existing HTML that was already rendered by React in a server environment.

##Code##
import { hydrateRoot } from 'react-dom/client';const domNode = document.getElementById('root');const root = hydrateRoot(domNode, reactNode);
##Code##
 React will attach to the HTML that exists inside the domNode, and take over managing the DOM inside it. An app fully built with React will usually only have one hydrateRoot call with its root component. See more examples below. domNode: A DOM element that was rendered as the root element on the server. reactNode: The “React node” used to render the existing HTML. This will usually be a piece of JSX like <App /> which was rendered with a ReactDOM Server method such as renderToPipeableStream(<App />). optional options: An object with options for this React root. optional onRecoverableError: Callback called when React automatically recovers from errors. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as used on the server. hydrateRoot returns an object with two methods: render and unmount. hydrateRoot() expects the rendered content to be identical with the server-rendered content. You should treat mismatches as bugs and fix them. In development mode, React warns about mismatches during hydration. There are no guarantees that attribute differences will be patched up in case of mismatches. This is important for performance reasons because in most apps, mismatches are rare, and so validating all markup would be prohibitively expensive. You’ll likely have only one hydrateRoot call in your app. If you use a framework, it might do this call for you. If your app is client-rendered with no HTML rendered already, using hydrateRoot() is not supported. Use createRoot() instead. Call root.render to update a React component inside a hydrated React root for a browser DOM element.

##Code##
root.render(<App />);
##Code##
 React will update <App /> in the hydrated root. See more examples below. reactNode: A “React node” that you want to update. This will usually be a piece of JSX like <App />, but you can also pass a React element constructed with createElement(), a string, a number, null, or undefined. root.render returns undefined. If you call root.render before the root has finished hydrating, React will clear the existing server-rendered HTML content and switch the entire root to client rendering. Call root.unmount to destroy a rendered tree inside a React root.

##Code##
root.unmount();
##Code##
 An app fully built with React will usually not have any calls to root.unmount. This is mostly useful if your React root’s DOM node (or any of its ancestors) may get removed from the DOM by some other code. For example, imagine a jQuery tab panel that removes inactive tabs from the DOM. If a tab gets removed, everything inside it (including the React roots inside) would get removed from the DOM as well. You need to tell React to “stop” managing the removed root’s content by calling root.unmount. Otherwise, the components inside the removed root won’t clean up and free up resources like subscriptions. Calling root.unmount will unmount all the components in the root and “detach” React from the root DOM node, including removing any event handlers or state in the tree. root.unmount does not accept any parameters. root.unmount returns undefined. Calling root.unmount will unmount all the components in the tree and “detach” React from the root DOM node. Once you call root.unmount you cannot call root.render again on the root. Attempting to call root.render on an unmounted root will throw a “Cannot update an unmounted root” error."
"Usage:  If your app’s HTML was generated by react-dom/server, you need to hydrate it on the client.

##Code##
import { hydrateRoot } from 'react-dom/client';hydrateRoot(document.getElementById('root'), <App />);
##Code##
 This will hydrate the server HTML inside the browser DOM node with the React component for your app. Usually, you will do it once at startup. If you use a framework, it might do this behind the scenes for you. To hydrate your app, React will “attach” your components’ logic to the initial generated HTML from the server. Hydration turns the initial HTML snapshot from the server into a fully interactive app that runs in the browser."
Server APIs for Node.js Streams:  These methods are only available in the environments with Node.js Streams: renderToPipeableStream renders a React tree to a pipeable Node.js Stream. renderToStaticNodeStream renders a non-interactive React tree to a Node.js Readable Stream.
"Server APIs for Web Streams:  These methods are only available in the environments with Web Streams, which includes browsers, Deno, and some modern edge runtimes: renderToReadableStream renders a React tree to a Readable Web Stream."
Server APIs for non-streaming environments:  These methods can be used in the environments that don’t support streams: renderToString renders a React tree to a string. renderToStaticMarkup renders a non-interactive React tree to a string. They have limited functionality compared to the streaming APIs.
Deprecated server APIs:  renderToNodeStream renders a React tree to a Node.js Readable stream. (Deprecated.)
"Reference:  On the server, call renderToNodeStream to get a Node.js Readable Stream which you can pipe into the response.

##Code##
import { renderToNodeStream } from 'react-dom/server';const stream = renderToNodeStream(<App />);stream.pipe(response);
##Code##
 On the client, call hydrateRoot to make the server-generated HTML interactive. See more examples below. reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. optional options: An object for server render. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot. A Node.js Readable Stream that outputs an HTML string. This method will wait for all Suspense boundaries to complete before returning any output. As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits. This is why it’s recommended that you migrate to renderToPipeableStream instead. The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like iconv-lite, which provides transform streams for transcoding text."
"Usage:  Call renderToNodeStream to get a Node.js Readable Stream which you can pipe to your server response:

##Code##
import { renderToNodeStream } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const stream = renderToNodeStream(<App />);  stream.pipe(response);});
##Code##
 The stream will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive."
"Reference:  Call renderToPipeableStream to render your React tree as HTML into a Node.js Stream.

##Code##
import { renderToPipeableStream } from 'react-dom/server';const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  }});
##Code##
 On the client, call hydrateRoot to make the server-generated HTML interactive. See more examples below. reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag. optional options: An object with streaming options. optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag. optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all. optional bootstrapModules: Like bootstrapScripts, but emits <script type=""module""> instead. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot. optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML. optional nonce: A nonce string to allow scripts for script-src Content-Security-Policy. optional onAllReady: A callback that fires when all rendering is complete, including both the shell and all additional content. You can use this instead of onShellReady for crawlers and static generation. If you start streaming here, you won’t get any progressive loading. The stream will contain the final HTML. optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted. optional onShellReady: A callback that fires right after the initial shell has been rendered. You can set the status code and call pipe here to start streaming. React will stream the additional content after the shell along with the inline <script> tags that place that replace the HTML loading fallbacks with the content. optional onShellError: A callback that fires if there was an error rendering the initial shell. It receives the error as an argument. No bytes were emitted from the stream yet, and neither onShellReady nor onAllReady will get called, so you can output a fallback HTML shell. optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic. renderToPipeableStream returns an object with two methods: pipe outputs the HTML into the provided Writable Node.js Stream. Call pipe in onShellReady if you want to enable streaming, or in onAllReady for crawlers and static generation. abort lets you abort server rendering and render the rest on the client."
"Usage:  Call renderToPipeableStream to render your React tree as HTML into a Node.js Stream:

##Code##
import { renderToPipeableStream } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const { pipe } = renderToPipeableStream(<App />, {    bootstrapScripts: ['/main.js'],    onShellReady() {      response.setHeader('content-type', 'text/html');      pipe(response);    }  });});
##Code##
 Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag. For example, it might look like this:

##Code##
export default function App() {  return (    <html>      <head>        <meta charSet=""utf-8"" />        <meta name=""viewport"" content=""width=device-width, initial-scale=1"" />        <link rel=""stylesheet"" href=""/styles.css""></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
##Code##
 React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:

##Code##
<!DOCTYPE html><html>  <!-- ... HTML from your components ... --></html><script src=""/main.js"" async=""""></script>
##Code##
 On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:

##Code##
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
##Code##
 This will attach event listeners to the server-generated HTML and make it interactive. Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Posts />    </ProfileLayout>  );}
##Code##
 Imagine that loading data for <Posts /> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
##Code##
 This tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts. You can further nest <Suspense> boundaries to create a more granular loading sequence:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
##Code##
 In this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible. Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load. Read more about how streaming HTML works. The part of your app outside of any <Suspense> boundaries is called the shell:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
##Code##
 It determines the earliest loading state that the user may see:

##Code##
<ProfileLayout>  <ProfileCover />  <BigSpinner /></ProfileLayout>
##Code##
 If you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <Suspense> boundaries so that the shell feels minimal but complete—like a skeleton of the entire page layout. The onShellReady callback fires when the entire shell has been rendered. Usually, you’ll start streaming then:

##Code##
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  }});
##Code##
 By the time onShellReady fires, components in nested <Suspense> boundaries might still be loading data. By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

##Code##
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  },  onError(error) {    console.error(error);    logServerCrashReport(error);  }});
##Code##
 If you provide a custom onError implementation, don’t forget to also log errors to the console like above. In this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
##Code##
 If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Override onShellError to send a fallback HTML that doesn’t rely on server rendering as the last resort:

##Code##
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onError(error) {    console.error(error);    logServerCrashReport(error);  }});
##Code##
 If there is an error while generating the shell, both onError and onShellError will fire. Use onError for error reporting and use onShellError to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only. In this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
##Code##
 If an error happens in the Posts component or somewhere inside it, React will try to recover from it: If retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable. If retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error. Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code. By dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, you’ll get the onShellError callback which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.

##Code##
const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.statusCode = 200;    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onError(error) {    console.error(error);    logServerCrashReport(error);  }});
##Code##
 If a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but you will still get onShellReady instead of onShellError. This is because React will try to recover from that error on the client, as described above. However, if you’d like, you can use the fact that something has errored to set the status code:

##Code##
let didError = false;const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.statusCode = didError ? 500 : 200;    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onError(error) {    didError = true;    console.error(error);    logServerCrashReport(error);  }});
##Code##
 This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell. You can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then your onError, onShellReady, and onShellError callbacks can do something different depending on the error type:

##Code##
let didError = false;let caughtError = null;function getStatusCode() {  if (didError) {    if (caughtError instanceof NotFoundError) {      return 404;    } else {      return 500;    }  } else {    return 200;  }}const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    response.statusCode = getStatusCode();    response.setHeader('content-type', 'text/html');    pipe(response);  },  onShellError(error) {   response.statusCode = getStatusCode();   response.setHeader('content-type', 'text/html');   response.send('<h1>Something went wrong</h1>');   },  onError(error) {    didError = true;    caughtError = error;    console.error(error);    logServerCrashReport(error);  }});
##Code##
 Keep in mind that once you emit the shell and start streaming, you can’t change the status code. Streaming offers a better user experience because the user can see the content as it becomes available. However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively. You can wait for all the content to load using the onAllReady callback:

##Code##
let didError = false;let isCrawler = // ... depends on your bot detection strategy ...const { pipe } = renderToPipeableStream(<App />, {  bootstrapScripts: ['/main.js'],  onShellReady() {    if (!isCrawler) {      response.statusCode = didError ? 500 : 200;      response.setHeader('content-type', 'text/html');      pipe(response);    }  },  onShellError(error) {    response.statusCode = 500;    response.setHeader('content-type', 'text/html');    response.send('<h1>Something went wrong</h1>');   },  onAllReady() {    if (isCrawler) {      response.statusCode = didError ? 500 : 200;      response.setHeader('content-type', 'text/html');      pipe(response);          }  },  onError(error) {    didError = true;    console.error(error);    logServerCrashReport(error);  }});
##Code##
 A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too. You can force the server rendering to “give up” after a timeout:

##Code##
const { pipe, abort } = renderToPipeableStream(<App />, {  // ...});setTimeout(() => {  abort();}, 10000);
##Code##
 React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client."
"Reference:  Call renderToReadableStream to render your React tree as HTML into a Readable Web Stream.

##Code##
import { renderToReadableStream } from 'react-dom/server';async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
##Code##
 On the client, call hydrateRoot to make the server-generated HTML interactive. See more examples below. reactNode: A React node you want to render to HTML. For example, a JSX element like <App />. It is expected to represent the entire document, so the App component should render the <html> tag. optional options: An object with streaming options. optional bootstrapScriptContent: If specified, this string will be placed in an inline <script> tag. optional bootstrapScripts: An array of string URLs for the <script> tags to emit on the page. Use this to include the <script> that calls hydrateRoot. Omit it if you don’t want to run React on the client at all. optional bootstrapModules: Like bootstrapScripts, but emits <script type=""module""> instead. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot. optional namespaceURI: A string with the root namespace URI for the stream. Defaults to regular HTML. Pass 'http://www.w3.org/2000/svg' for SVG or 'http://www.w3.org/1998/Math/MathML' for MathML. optional nonce: A nonce string to allow scripts for script-src Content-Security-Policy. optional onError: A callback that fires whenever there is a server error, whether recoverable or not. By default, this only calls console.error. If you override it to log crash reports, make sure that you still call console.error. You can also use it to adjust the status code before the shell is emitted. optional progressiveChunkSize: The number of bytes in a chunk. Read more about the default heuristic. optional signal: An abort signal that lets you abort server rendering and render the rest on the client. renderToReadableStream returns a Promise: If rendering the shell is successful, that Promise will resolve to a Readable Web Stream. If rendering the shell fails, the Promise will be rejected. Use this to output a fallback shell. The returned stream has an additional property: allReady: A Promise that resolves when all rendering is complete, including both the shell and all additional content. You can await stream.allReady before returning a response for crawlers and static generation. If you do that, you won’t get any progressive loading. The stream will contain the final HTML."
"Usage:  Call renderToReadableStream to render your React tree as HTML into a Readable Web Stream:

##Code##
import { renderToReadableStream } from 'react-dom/server';async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
##Code##
 Along with the root component, you need to provide a list of bootstrap <script> paths. Your root component should return the entire document including the root <html> tag. For example, it might look like this:

##Code##
export default function App() {  return (    <html>      <head>        <meta charSet=""utf-8"" />        <meta name=""viewport"" content=""width=device-width, initial-scale=1"" />        <link rel=""stylesheet"" href=""/styles.css""></link>        <title>My app</title>      </head>      <body>        <Router />      </body>    </html>  );}
##Code##
 React will inject the doctype and your bootstrap <script> tags into the resulting HTML stream:

##Code##
<!DOCTYPE html><html>  <!-- ... HTML from your components ... --></html><script src=""/main.js"" async=""""></script>
##Code##
 On the client, your bootstrap script should hydrate the entire document with a call to hydrateRoot:

##Code##
import { hydrateRoot } from 'react-dom/client';import App from './App.js';hydrateRoot(document, <App />);
##Code##
 This will attach event listeners to the server-generated HTML and make it interactive. Streaming allows the user to start seeing the content even before all the data has loaded on the server. For example, consider a profile page that shows a cover, a sidebar with friends and photos, and a list of posts:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Posts />    </ProfileLayout>  );}
##Code##
 Imagine that loading data for <Posts /> takes some time. Ideally, you’d want to show the rest of the profile page content to the user without waiting for the posts. To do this, wrap Posts in a <Suspense> boundary:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Sidebar>        <Friends />        <Photos />      </Sidebar>      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
##Code##
 This tells React to start streaming the HTML before Posts loads its data. React will send the HTML for the loading fallback (PostsGlimmer) first, and then, when Posts finishes loading its data, React will send the remaining HTML along with an inline <script> tag that replaces the loading fallback with that HTML. From the user’s perspective, the page will first appear with the PostsGlimmer, later replaced by the Posts. You can further nest <Suspense> boundaries to create a more granular loading sequence:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
##Code##
 In this example, React can start streaming the page even earlier. Only ProfileLayout and ProfileCover must finish rendering first because they are not wrapped in any <Suspense> boundary. However, if Sidebar, Friends, or Photos need to load some data, React will send the HTML for the BigSpinner fallback instead. Then, as more data becomes available, more content will continue to be revealed until all of it becomes visible. Streaming does not need to wait for React itself to load in the browser, or for your app to become interactive. The HTML content from the server will get progressively revealed before any of the <script> tags load. Read more about how streaming HTML works. The part of your app outside of any <Suspense> boundaries is called the shell:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<BigSpinner />}>        <Sidebar>          <Friends />          <Photos />        </Sidebar>        <Suspense fallback={<PostsGlimmer />}>          <Posts />        </Suspense>      </Suspense>    </ProfileLayout>  );}
##Code##
 It determines the earliest loading state that the user may see:

##Code##
<ProfileLayout>  <ProfileCover />  <BigSpinner /></ProfileLayout>
##Code##
 If you wrap the whole app into a <Suspense> boundary at the root, the shell will only contain that spinner. However, that’s not a pleasant user experience because seeing a big spinner on the screen can feel slower and more annoying than waiting a bit more and seeing the real layout. This is why usually you’ll want to place the <Suspense> boundaries so that the shell feels minimal but complete—like a skeleton of the entire page layout. The async call to renderToReadableStream will resolve to a stream as soon as the entire shell has been rendered. Usually, you’ll start streaming then by creating and returning a response with that stream:

##Code##
async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js']  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
##Code##
 By the time the stream is returned, components in nested <Suspense> boundaries might still be loading data. By default, all errors on the server are logged to console. You can override this behavior to log crash reports:

##Code##
async function handler(request) {  const stream = await renderToReadableStream(<App />, {    bootstrapScripts: ['/main.js'],    onError(error) {      console.error(error);      logServerCrashReport(error);    }  });  return new Response(stream, {    headers: { 'content-type': 'text/html' },  });}
##Code##
 If you provide a custom onError implementation, don’t forget to also log errors to the console like above. In this example, the shell contains ProfileLayout, ProfileCover, and PostsGlimmer:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
##Code##
 If an error occurs while rendering those components, React won’t have any meaningful HTML to send to the client. Wrap your renderToReadableStream call in a try...catch to send a fallback HTML that doesn’t rely on server rendering as the last resort:

##Code##
async function handler(request) {  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
##Code##
 If there is an error while generating the shell, both onError and your catch block will fire. Use onError for error reporting and use the catch block to send the fallback HTML document. Your fallback HTML does not have to be an error page. Instead, you may include an alternative shell that renders your app on the client only. In this example, the <Posts /> component is wrapped in <Suspense> so it is not a part of the shell:

##Code##
function ProfilePage() {  return (    <ProfileLayout>      <ProfileCover />      <Suspense fallback={<PostsGlimmer />}>        <Posts />      </Suspense>    </ProfileLayout>  );}
##Code##
 If an error happens in the Posts component or somewhere inside it, React will try to recover from it: If retrying rendering Posts on the client also fails, React will throw the error on the client. As with all the errors thrown during rendering, the closest parent error boundary determines how to present the error to the user. In practice, this means that the user will see a loading indicator until it is certain that the error is not recoverable. If retrying rendering Posts on the client succeeds, the loading fallback from the server will be replaced with the client rendering output. The user will not know that there was a server error. However, the server onError callback and the client onRecoverableError callbacks will fire so that you can get notified about the error. Streaming introduces a tradeoff. You want to start streaming the page as early as possible so that the user can see the content sooner. However, once you start streaming, you can no longer set the response status code. By dividing your app into the shell (above all <Suspense> boundaries) and the rest of the content, you’ve already solved a part of this problem. If the shell errors, your catch block will run which lets you set the error status code. Otherwise, you know that the app may recover on the client, so you can send “OK”.

##Code##
async function handler(request) {  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
##Code##
 If a component outside the shell (i.e. inside a <Suspense> boundary) throws an error, React will not stop rendering. This means that the onError callback will fire, but your code will continue running without getting into the catch block. This is because React will try to recover from that error on the client, as described above. However, if you’d like, you can use the fact that something has errored to set the status code:

##Code##
async function handler(request) {  try {    let didError = false;    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: didError ? 500 : 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
##Code##
 This will only catch errors outside the shell that happened while generating the initial shell content, so it’s not exhaustive. If knowing whether an error occurred for some content is critical, you can move it up into the shell. You can create your own Error subclasses and use the instanceof operator to check which error is thrown. For example, you can define a custom NotFoundError and throw it from your component. Then you can save the error in onError and do something different before returning the response depending on the error type:

##Code##
async function handler(request) {  let didError = false;  let caughtError = null;  function getStatusCode() {    if (didError) {      if (caughtError instanceof NotFoundError) {        return 404;      } else {        return 500;      }    } else {      return 200;    }  }  try {    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        caughtError = error;        console.error(error);        logServerCrashReport(error);      }    });    return new Response(stream, {      status: getStatusCode(),      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: getStatusCode(),      headers: { 'content-type': 'text/html' },    });  }}
##Code##
 Keep in mind that once you emit the shell and start streaming, you can’t change the status code. Streaming offers a better user experience because the user can see the content as it becomes available. However, when a crawler visits your page, or if you’re generating the pages at the build time, you might want to let all of the content load first and then produce the final HTML output instead of revealing it progressively. You can wait for all the content to load by awaiting the stream.allReady Promise:

##Code##
async function handler(request) {  try {    let didError = false;    const stream = await renderToReadableStream(<App />, {      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    let isCrawler = // ... depends on your bot detection strategy ...    if (isCrawler) {      await stream.allReady;    }    return new Response(stream, {      status: didError ? 500 : 200,      headers: { 'content-type': 'text/html' },    });  } catch (error) {    return new Response('<h1>Something went wrong</h1>', {      status: 500,      headers: { 'content-type': 'text/html' },    });  }}
##Code##
 A regular visitor will get a stream of progressively loaded content. A crawler will receive the final HTML output after all the data loads. However, this also means that the crawler will have to wait for all data, some of which might be slow to load or error. Depending on your app, you could choose to send the shell to the crawlers too. You can force the server rendering to “give up” after a timeout:

##Code##
async function handler(request) {  try {    const controller = new AbortController();    setTimeout(() => {      controller.abort();    }, 10000);    const stream = await renderToReadableStream(<App />, {      signal: controller.signal,      bootstrapScripts: ['/main.js'],      onError(error) {        didError = true;        console.error(error);        logServerCrashReport(error);      }    });    // ...
##Code##
 React will flush the remaining loading fallbacks as HTML, and will attempt to render the rest on the client."
"Reference:  On the server, call renderToStaticMarkup to render your app to HTML.

##Code##
import { renderToStaticMarkup } from 'react-dom/server';const html = renderToStaticMarkup(<Page />);
##Code##
 It will produce non-interactive HTML output of your React components. See more examples below. reactNode: A React node you want to render to HTML. For example, a JSX node like <Page />. optional options: An object for server render. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. An HTML string. renderToStaticMarkup output cannot be hydrated. renderToStaticMarkup has limited Suspense support. If a component suspends, renderToStaticMarkup immediately sends its fallback as HTML. renderToStaticMarkup works in the browser, but using it in the client code is not recommended. If you need to render a component to HTML in the browser, get the HTML by rendering it into a DOM node."
"Usage:  Call renderToStaticMarkup to render your app to an HTML string which you can send with your server response:

##Code##
import { renderToStaticMarkup } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const html = renderToStaticMarkup(<Page />);  response.send(html);});
##Code##
 This will produce the initial non-interactive HTML output of your React components."
"Reference:  On the server, call renderToStaticNodeStream to get a Node.js Readable Stream.

##Code##
import { renderToStaticNodeStream } from 'react-dom/server';const stream = renderToStaticNodeStream(<Page />);stream.pipe(response);
##Code##
 See more examples below. The stream will produce non-interactive HTML output of your React components. reactNode: A React node you want to render to HTML. For example, a JSX element like <Page />. optional options: An object for server render. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. A Node.js Readable Stream that outputs an HTML string. The resulting HTML can’t be hydrated on the client. renderToStaticNodeStream output cannot be hydrated. This method will wait for all Suspense boundaries to complete before returning any output. As of React 18, this method buffers all of its output, so it doesn’t actually provide any streaming benefits. The returned stream is a byte stream encoded in utf-8. If you need a stream in another encoding, take a look at a project like iconv-lite, which provides transform streams for transcoding text."
"Usage:  Call renderToStaticNodeStream to get a Node.js Readable Stream which you can pipe to your server response:

##Code##
import { renderToStaticNodeStream } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const stream = renderToStaticNodeStream(<Page />);  stream.pipe(response);});
##Code##
 The stream will produce the initial non-interactive HTML output of your React components."
"Reference:  On the server, call renderToString to render your app to HTML.

##Code##
import { renderToString } from 'react-dom/server';const html = renderToString(<App />);
##Code##
 On the client, call hydrateRoot to make the server-generated HTML interactive. See more examples below. reactNode: A React node you want to render to HTML. For example, a JSX node like <App />. optional options: An object for server render. optional identifierPrefix: A string prefix React uses for IDs generated by useId. Useful to avoid conflicts when using multiple roots on the same page. Must be the same prefix as passed to hydrateRoot. An HTML string. renderToString has limited Suspense support. If a component suspends, renderToString immediately sends its fallback as HTML. renderToString works in the browser, but using it in the client code is not recommended."
"Usage:  Call renderToString to render your app to an HTML string which you can send with your server response:

##Code##
import { renderToString } from 'react-dom/server';// The route handler syntax depends on your backend frameworkapp.use('/', (request, response) => {  const html = renderToString(<App />);  response.send(html);});
##Code##
 This will produce the initial non-interactive HTML output of your React components. On the client, you will need to call hydrateRoot to hydrate that server-generated HTML and make it interactive."
"Alternatives:  renderToString returns a string immediately, so it does not support streaming or waiting for data. When possible, we recommend using these fully-featured alternatives: If you use Node.js, use renderToPipeableStream. If you use Deno or a modern edge runtime with Web Streams, use renderToReadableStream. You can continue using renderToString if your server environment does not support streams. Sometimes, renderToString is used on the client to convert some component to HTML.

##Code##
// 🚩 Unnecessary: using renderToString on the clientimport { renderToString } from 'react-dom/server';const html = renderToString(<MyIcon />);console.log(html); // For example, ""<svg>...</svg>""
##Code##
 Importing react-dom/server on the client unnecessarily increases your bundle size and should be avoided. If you need to render some component to HTML in the browser, use createRoot and read HTML from the DOM:

##Code##
import { createRoot } from 'react-dom/client';import { flushSync } from 'react-dom';const div = document.createElement('div');const root = createRoot(div);flushSync(() => {  root.render(<MyIcon />);});console.log(div.innerHTML); // For example, ""<svg>...</svg>""
##Code##
 The flushSync call is necessary so that the DOM is updated before reading its innerHTML property."
"Troubleshooting:  renderToString does not fully support Suspense. If some component suspends (for example, because it’s defined with lazy or fetches data), renderToString will not wait for its content to resolve. Instead, renderToString will find the closest <Suspense> boundary above it and render its fallback prop in the HTML. The content will not appear until the client code loads. To solve this, use one of the recommended streaming solutions. They can stream content in chunks as it resolves on the server so that the user sees the page being progressively filled in before the client code loads."
"Components and Hooks must be pure:  Purity in Components and Hooks is a key rule of React that makes your app predictable, easy to debug, and allows React to automatically optimize your code. Components must be idempotent – React components are assumed to always return the same output with respect to their inputs – props, state, and context. Side effects must run outside of render – Side effects should not run in render, as React can render components multiple times to create the best possible user experience. Props and state are immutable – A component’s props and state are immutable snapshots with respect to a single render. Never mutate them directly. Return values and arguments to Hooks are immutable – Once values are passed to a Hook, you should not modify them. Like props in JSX, values become immutable when passed to a Hook. Values are immutable after being passed to JSX – Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created."
"React calls Components and Hooks:  React is responsible for rendering components and hooks when necessary to optimize the user experience. It is declarative: you tell React what to render in your component’s logic, and React will figure out how best to display it to your user. Never call component functions directly – Components should only be used in JSX. Don’t call them as regular functions. Never pass around hooks as regular values – Hooks should only be called inside of components. Never pass it around as a regular value."
"Rules of Hooks:  Hooks are defined using JavaScript functions, but they represent a special type of reusable UI logic with restrictions on where they can be called. You need to follow the Rules of Hooks when using them. Only call Hooks at the top level – Don’t call Hooks inside loops, conditions, or nested functions. Instead, always use Hooks at the top level of your React function, before any early returns. Only call Hooks from React functions – Don’t call Hooks from regular JavaScript functions."
"Components and Hooks must be idempotent:  Components must always return the same output with respect to their inputs – props, state, and context. This is known as idempotency. Idempotency is a term popularized in functional programming. It refers to the idea that you always get the same result everytime you run that piece of code with the same inputs. This means that all code that runs during render must also be idempotent in order for this rule to hold. For example, this line of code is not idempotent (and therefore, neither is the component):

##Code##
function Clock() {  const time = new Date(); // 🔴 Bad: always returns a different result!  return <span>{time.toLocaleString()}</span>}
##Code##
 new Date() is not idempotent as it always returns the current date and changes its result every time it’s called. When you render the above component, the time displayed on the screen will stay stuck on the time that the component was rendered. Similarly, functions like Math.random() also aren’t idempotent, because they return different results every time they’re called, even when the inputs are the same. This doesn’t mean you shouldn’t use non-idempotent functions like new Date() at all – you should just avoid using them during render. In this case, we can synchronize the latest date to this component using an Effect:"
"Side effects must run outside of render:  Side effects should not run in render, as React can render components multiple times to create the best possible user experience. While render must be kept pure, side effects are necessary at some point in order for your app to do anything interesting, like showing something on the screen! The key point of this rule is that side effects should not run in render, as React can render components multiple times. In most cases, you’ll use event handlers to handle side effects. Using an event handler explicitly tells React that this code doesn’t need to run during render, keeping render pure. If you’ve exhausted all options – and only as a last resort – you can also handle side effects using useEffect. One common example of a side effect is mutation, which in JavaScript refers to changing the value of a non-primitive value. In general, while mutation is not idiomatic in React, local mutation is absolutely fine:

##Code##
function FriendList({ friends }) {  const items = []; // ✅ Good: locally created  for (let i = 0; i < friends.length; i++) {    const friend = friends[i];    items.push(      <Friend key={friend.id} friend={friend} />    ); // ✅ Good: local mutation is okay  }  return <section>{items}</section>;}
##Code##
 There is no need to contort your code to avoid local mutation. Array.map could also be used here for brevity, but there is nothing wrong with creating a local array and then pushing items into it during render. Even though it looks like we are mutating items, the key point to note is that this code only does so locally – the mutation isn’t “remembered” when the component is rendered again. In other words, items only stays around as long as the component does. Because items is always recreated every time <FriendList /> is rendered, the component will always return the same result. On the other hand, if items was created outside of the component, it holds on to its previous values and remembers changes:

##Code##
const items = []; // 🔴 Bad: created outside of the componentfunction FriendList({ friends }) {  for (let i = 0; i < friends.length; i++) {    const friend = friends[i];    items.push(      <Friend key={friend.id} friend={friend} />    ); // 🔴 Bad: mutates a value created outside of render  }  return <section>{items}</section>;}
##Code##
 When <FriendList /> runs again, we will continue appending friends to items every time that component is run, leading to multiple duplicated results. This version of <FriendList /> has observable side effects during render and breaks the rule. Lazy initialization is also fine despite not being fully “pure”:

##Code##
function ExpenseForm() {  SuperCalculator.initializeIfNotReady(); // ✅ Good: if it doesn't affect other components  // Continue rendering...}
##Code##
 Side effects that are directly visible to the user are not allowed in the render logic of React components. In other words, merely calling a component function shouldn’t by itself produce a change on the screen.

##Code##
function ProductDetailPage({ product }) {  document.window.title = product.title; // 🔴 Bad: Changes the DOM}
##Code##
 One way to achieve the desired result of updating window.title outside of render is to synchronize the component with window. As long as calling a component multiple times is safe and doesn’t affect the rendering of other components, React doesn’t care if it’s 100% pure in the strict functional programming sense of the word. It is more important that components must be idempotent."
"Props and state are immutable:  A component’s props and state are immutable snapshots. Never mutate them directly. Instead, pass new props down, and use the setter function from useState. You can think of the props and state values as snapshots that are updated after rendering. For this reason, you don’t modify the props or state variables directly: instead you pass new props, or use the setter function provided to you to tell React that state needs to update the next time the component is rendered. Props are immutable because if you mutate them, the application will produce inconsistent output, which can be hard to debug since it may or may not work depending on the circumstance.

##Code##
function Post({ item }) {  item.url = new Url(item.url, base); // 🔴 Bad: never mutate props directly  return <Link url={item.url}>{item.title}</Link>;}
##Code##


##Code##
function Post({ item }) {  const url = new Url(item.url, base); // ✅ Good: make a copy instead  return <Link url={url}>{item.title}</Link>;}
##Code##
 useState returns the state variable and a setter to update that state.

##Code##
const [stateVariable, setter] = useState(0);
##Code##
 Rather than updating the state variable in-place, we need to update it using the setter function that is returned by useState. Changing values on the state variable doesn’t cause the component to update, leaving your users with an outdated UI. Using the setter function informs React that the state has changed, and that we need to queue a re-render to update the UI.

##Code##
function Counter() {  const [count, setCount] = useState(0);  function handleClick() {    count = count + 1; // 🔴 Bad: never mutate state directly  }  return (    <button onClick={handleClick}>      You pressed me {count} times    </button>  );}
##Code##


##Code##
function Counter() {  const [count, setCount] = useState(0);  function handleClick() {    setCount(count + 1); // ✅ Good: use the setter function returned by useState  }  return (    <button onClick={handleClick}>      You pressed me {count} times    </button>  );}
##Code##"
"Return values and arguments to Hooks are immutable:  Once values are passed to a hook, you should not modify them. Like props in JSX, values become immutable when passed to a hook.

##Code##
function useIconStyle(icon) {  const theme = useContext(ThemeContext);  if (icon.enabled) {    icon.className = computeStyle(icon, theme); // 🔴 Bad: never mutate hook arguments directly  }  return icon;}
##Code##


##Code##
function useIconStyle(icon) {  const theme = useContext(ThemeContext);  const newIcon = { ...icon }; // ✅ Good: make a copy instead  if (icon.enabled) {    newIcon.className = computeStyle(icon, theme);  }  return newIcon;}
##Code##
 One important principle in React is local reasoning: the ability to understand what a component or hook does by looking at its code in isolation. Hooks should be treated like “black boxes” when they are called. For example, a custom hook might have used its arguments as dependencies to memoize values inside it:

##Code##
function useIconStyle(icon) {  const theme = useContext(ThemeContext);  return useMemo(() => {    const newIcon = { ...icon };    if (icon.enabled) {      newIcon.className = computeStyle(icon, theme);    }    return newIcon;  }, [icon, theme]);}
##Code##
 If you were to mutate the Hooks arguments, the custom hook’s memoization will become incorrect, so it’s important to avoid doing that.

##Code##
style = useIconStyle(icon);         // `style` is memoized based on `icon`icon.enabled = false;               // Bad: 🔴 never mutate hook arguments directlystyle = useIconStyle(icon);         // previously memoized result is returned
##Code##


##Code##
style = useIconStyle(icon);         // `style` is memoized based on `icon`icon = { ...icon, enabled: false }; // Good: ✅ make a copy insteadstyle = useIconStyle(icon);         // new value of `style` is calculated
##Code##
 Similarly, it’s important to not modify the return values of Hooks, as they may have been memoized."
"Values are immutable after being passed to JSX:  Don’t mutate values after they’ve been used in JSX. Move the mutation before the JSX is created. When you use JSX in an expression, React may eagerly evaluate the JSX before the component finishes rendering. This means that mutating values after they’ve been passed to JSX can lead to outdated UIs, as React won’t know to update the component’s output.

##Code##
function Page({ colour }) {  const styles = { colour, size: ""large"" };  const header = <Header styles={styles} />;  styles.size = ""small""; // 🔴 Bad: styles was already used in the JSX above  const footer = <Footer styles={styles} />;  return (    <>      {header}      <Content />      {footer}    </>  );}
##Code##


##Code##
function Page({ colour }) {  const headerStyles = { colour, size: ""large"" };  const header = <Header styles={headerStyles} />;  const footerStyles = { colour, size: ""small"" }; // ✅ Good: we created a new value  const footer = <Footer styles={footerStyles} />;  return (    <>      {header}      <Content />      {footer}    </>  );}
##Code##"
"Never call component functions directly:  Components should only be used in JSX. Don’t call them as regular functions. React should call it. React must decide when your component function is called during rendering. In React, you do this using JSX.

##Code##
function BlogPost() {  return <Layout><Article /></Layout>; // ✅ Good: Only use components in JSX}
##Code##


##Code##
function BlogPost() {  return <Layout>{Article()}</Layout>; // 🔴 Bad: Never call them directly}
##Code##
 If a component contains Hooks, it’s easy to violate the Rules of Hooks when components are called directly in a loop or conditionally. Letting React orchestrate rendering also allows a number of benefits: Components become more than functions. React can augment them with features like local state through Hooks that are tied to the component’s identity in the tree. Component types participate in reconciliation. By letting React call your components, you also tell it more about the conceptual structure of your tree. For example, when you move from rendering <Feed> to the <Profile> page, React won’t attempt to re-use them. React can enhance your user experience. For example, it can let the browser do some work between component calls so that re-rendering a large component tree doesn’t block the main thread. A better debugging story. If components are first-class citizens that the library is aware of, we can build rich developer tools for introspection in development. More efficient reconciliation. React can decide exactly which components in the tree need re-rendering and skip over the ones that don’t. That makes your app faster and more snappy."
"Never pass around Hooks as regular values:  Hooks should only be called inside of components or Hooks. Never pass it around as a regular value. Hooks allow you to augment a component with React features. They should always be called as a function, and never passed around as a regular value. This enables local reasoning, or the ability for developers to understand everything a component can do by looking at that component in isolation. Breaking this rule will cause React to not automatically optimize your component. Hooks should be as “static” as possible. This means you shouldn’t dynamically mutate them. For example, this means you shouldn’t write higher order Hooks:

##Code##
function ChatInput() {  const useDataWithLogging = withLogging(useData); // 🔴 Bad: don't write higher order Hooks  const data = useDataWithLogging();}
##Code##
 Hooks should be immutable and not be mutated. Instead of mutating a Hook dynamically, create a static version of the Hook with the desired functionality.

##Code##
function ChatInput() {  const data = useDataWithLogging(); // ✅ Good: Create a new version of the Hook}function useDataWithLogging() {  // ... Create a new version of the Hook and inline the logic here}
##Code##
 Hooks should also not be dynamically used: for example, instead of doing dependency injection in a component by passing a Hook as a value:

##Code##
function ChatInput() {  return <Button useData={useDataWithLogging} /> // 🔴 Bad: don't pass Hooks as props}
##Code##
 You should always inline the call of the Hook into that component and handle any logic in there.

##Code##
function ChatInput() {  return <Button />}function Button() {  const data = useDataWithLogging(); // ✅ Good: Use the Hook directly}function useDataWithLogging() {  // If there's any conditional logic to change the Hook's behavior, it should be inlined into  // the Hook}
##Code##
 This way, <Button /> is much easier to understand and debug. When Hooks are used in dynamic ways, it increases the complexity of your app greatly and inhibits local reasoning, making your team less productive in the long term. It also makes it easier to accidentally break the Rules of Hooks that Hooks should not be called conditionally. If you find yourself needing to mock components for tests, it’s better to mock the server instead to respond with canned data. If possible, it’s also usually more effective to test your app with end-to-end tests."
"Only call Hooks at the top level:  Functions whose names start with use are called Hooks in React. Don’t call Hooks inside loops, conditions, nested functions, or try/catch/finally blocks. Instead, always use Hooks at the top level of your React function, before any early returns. You can only call Hooks while React is rendering a function component: ✅ Call them at the top level in the body of a function component. ✅ Call them at the top level in the body of a custom Hook.

##Code##
function Counter() {  // ✅ Good: top-level in a function component  const [count, setCount] = useState(0);  // ...}function useWindowWidth() {  // ✅ Good: top-level in a custom Hook  const [width, setWidth] = useState(window.innerWidth);  // ...}
##Code##
 It’s not supported to call Hooks (functions starting with use) in any other cases, for example: 🔴 Do not call Hooks inside conditions or loops. 🔴 Do not call Hooks after a conditional return statement. 🔴 Do not call Hooks in event handlers. 🔴 Do not call Hooks in class components. 🔴 Do not call Hooks inside functions passed to useMemo, useReducer, or useEffect. 🔴 Do not call Hooks inside try/catch/finally blocks. If you break these rules, you might see this error.

##Code##
function Bad({ cond }) {  if (cond) {    // 🔴 Bad: inside a condition (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad() {  for (let i = 0; i < 10; i++) {    // 🔴 Bad: inside a loop (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad({ cond }) {  if (cond) {    return;  }  // 🔴 Bad: after a conditional return (to fix, move it before the return!)  const theme = useContext(ThemeContext);  // ...}function Bad() {  function handleClick() {    // 🔴 Bad: inside an event handler (to fix, move it outside!)    const theme = useContext(ThemeContext);  }  // ...}function Bad() {  const style = useMemo(() => {    // 🔴 Bad: inside useMemo (to fix, move it outside!)    const theme = useContext(ThemeContext);    return createStyle(theme);  });  // ...}class Bad extends React.Component {  render() {    // 🔴 Bad: inside a class component (to fix, write a function component instead of a class!)    useEffect(() => {})    // ...  }}function Bad() {  try {    // 🔴 Bad: inside try/catch/finally block (to fix, move it outside!)    const [x, setX] = useState(0);  } catch {    const [x, setX] = useState(1);  }}
##Code##
 You can use the eslint-plugin-react-hooks plugin to catch these mistakes."
"Only call Hooks from React functions:  Don’t call Hooks from regular JavaScript functions. Instead, you can: ✅ Call Hooks from React function components. ✅ Call Hooks from custom Hooks. By following this rule, you ensure that all stateful logic in a component is clearly visible from its source code.

##Code##
function FriendList() {  const [onlineStatus, setOnlineStatus] = useOnlineStatus(); // ✅}function setOnlineStatus() { // ❌ Not a component or custom Hook!  const [onlineStatus, setOnlineStatus] = useOnlineStatus();}
##Code##"
